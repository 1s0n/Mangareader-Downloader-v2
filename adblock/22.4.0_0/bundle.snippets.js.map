{"version":3,"file":"bundle.snippets.js","sources":["../../node_modules/proxy-pants/esm/proxy.js","../../node_modules/proxy-pants/esm/function.js","../../node_modules/proxy-pants/esm/bound.js","../../node_modules/proxy-pants/esm/object.js","../../node_modules/proxy-pants/esm/secure.js","../../lib/content/environment.js","../../lib/content/utils/env.js","../../node_modules/transform-once/esm/index.js","../../lib/content/utils/transformer.js","../../node_modules/proxy-pants/esm/array.js","../../node_modules/proxy-pants/esm/globals.js","../../node_modules/proxy-pants/esm/chain.js","../../lib/content/$.js","../../lib/content/utils/dom.js","../../lib/content/behavioral/simulate-event-poc.js","../../lib/content/utils/general.js","../../lib/content/introspection/debug.js","../../lib/content/introspection/log.js","../../lib/content/introspection/race.js","../../lib/content/conditional-hiding/hide-if-contains.js","../../lib/content/conditional-hiding/hide-if-contains-and-matches-style.js","../../lib/content/conditional-hiding/hide-if-contains-image.js","../../lib/content/conditional-hiding/hide-if-contains-visible-text.js","../../lib/content/conditional-hiding/hide-if-has-and-matches-style.js","../../lib/content/conditional-hiding/hide-if-labelled-by.js","../../lib/content/introspection/profile.js","../../lib/content/conditional-hiding/hide-if-matches-xpath.js","../../node_modules/proxy-pants/esm/accessor.js","../../lib/content/utils/execution.js","../../lib/content/behavioral/abort-current-inline-script.js","../../lib/content/behavioral/abort-on-iframe-property-read.js","../../lib/content/behavioral/abort-on-iframe-property-write.js","../../lib/content/behavioral/abort-on-property-read.js","../../lib/content/behavioral/abort-on-property-write.js","../../lib/content/behavioral/cookie-remover.js","../../lib/content/behavioral/freeze-element.js","../../lib/content/conditional-hiding/hide-if-shadow-contains.js","../../lib/content/behavioral/json-override.js","../../lib/content/behavioral/json-prune.js","../../lib/content/behavioral/override-property-read.js","../../lib/content/behavioral/prevent-listener.js","../../lib/content/behavioral/strip-fetch-query-parameter.js","../../lib/content/introspection/trace.js","../../lib/webext/injectedMeta.js","../../lib/webext/snippets.js"],"sourcesContent":["const $ = Proxy;\nexport {$ as Proxy};\n","import {Proxy} from './proxy.js';\n\nconst {apply: a, bind: b, call: c} = Function;\nexport const apply = c.bind(a);\nexport const bind = c.bind(b);\nexport const call = c.bind(c);\n\nconst applierHandler = {\n  get(target, name) {\n    return bind(a, target[name]);\n  }\n};\nexport const applier = target => new Proxy(target, applierHandler);\n\nconst callerHandler = {\n  get(target, name) {\n    return bind(c, target[name]);\n  }\n};\nexport const caller = target => new Proxy(target, callerHandler);\n\nexport const proxy = (source, target) => new Proxy(source, {\n  apply: (_, self, args) => apply(target, self, args)\n});\n","import {Proxy} from './proxy.js';\nimport {bind} from './function.js';\n\nconst handler = {\n  get(target, name) {\n    return bind(target[name], target);\n  }\n};\nexport const bound = target => new Proxy(target, handler);\n","import {bound} from './bound.js';\nimport {caller} from './function.js';\n\nconst {\n  assign,\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf\n} = bound(Object);\n\nconst {hasOwnProperty} = caller({});\n\nexport {\n  assign,\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  hasOwnProperty\n};\n","import {Proxy} from './proxy.js';\nimport {\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptors,\n} from './object.js';\n\nconst {species} = Symbol;\n\nconst handler = {\n  get(target, name) {\n    const Native = target[name];\n    class Secure extends Native {}\n\n    const proto = getOwnPropertyDescriptors(Native.prototype);\n    delete proto.constructor;\n    freeze(defineProperties(Secure.prototype, proto));\n\n    const statics = getOwnPropertyDescriptors(Native);\n    delete statics.length;\n    delete statics.prototype;\n    statics[species] = {value: Secure};\n    return freeze(defineProperties(Secure, statics));\n  }\n};\n\nexport const secure = target => new Proxy(target, handler);\n","/**\n * @typedef {object} Environment\n * @property {Array.<Array>} debugCSSProperties Highlighting options.\n * CSS properties to be applied to the targeted element.\n * @property {string} world Target injection world. 'ISOLATED' or 'MAIN'.\n */\n\n/**\n * A configuration object passed by integrators.\n * @type {Environment}\n * @private\n */\n// eslint-disable-next-line no-undef\nexport const libEnvironment = typeof environment !== \"undefined\" ? environment :\n                                                                   {};\n","/* global chrome, browser, globalThis */\n\nimport {bound} from \"proxy-pants/bound\";\nimport {secure} from \"proxy-pants/secure\";\nimport {libEnvironment} from \"../environment.js\";\n\nif (typeof globalThis === \"undefined\")\n  window.globalThis = window;\n\nconst {apply, ownKeys} = bound(Reflect);\n\nconst worldEnvDefined = \"world\" in libEnvironment;\nconst isIsolatedWorld = worldEnvDefined && libEnvironment.world === \"ISOLATED\";\nconst isMainWorld = worldEnvDefined && libEnvironment.world === \"MAIN\";\nconst isChrome = typeof chrome === \"object\" && !!chrome.runtime;\nconst isOtherThanChrome = typeof browser === \"object\" && !!browser.runtime;\nconst isExtensionContext = !isMainWorld &&\n  (isIsolatedWorld || isChrome || isOtherThanChrome);\nconst copyIfExtension = value => isExtensionContext ?\n  value :\n  create(value, getOwnPropertyDescriptors(value));\n\nconst {\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors\n} = bound(Object);\n\nconst invokes = bound(globalThis);\nconst classes = isExtensionContext ? globalThis : secure(globalThis);\nconst {Map, RegExp, Set, WeakMap, WeakSet} = classes;\n\nconst augment = (source, target, method = null) => {\n  const known = ownKeys(target);\n  for (const key of ownKeys(source)) {\n    if (known.includes(key))\n      continue;\n\n    const descriptor = getOwnPropertyDescriptor(source, key);\n    if (method && \"value\" in descriptor) {\n      const {value} = descriptor;\n      if (typeof value === \"function\")\n        descriptor.value = method(value);\n    }\n    defineProperty(target, key, descriptor);\n  }\n};\n\nconst primitive = name => {\n  const Super = classes[name];\n  class Class extends Super {}\n  const {toString, valueOf} = Super.prototype;\n  defineProperties(Class.prototype, {\n    toString: {value: toString},\n    valueOf: {value: valueOf}\n  });\n  const type = name.toLowerCase();\n  const method = callback => function() {\n    const result = apply(callback, this, arguments);\n    return typeof result === type ? new Class(result) : result;\n  };\n  augment(Super, Class, method);\n  augment(Super.prototype, Class.prototype, method);\n  return Class;\n};\n\nconst variables = freeze({\n  frozen: new WeakMap(),\n  hidden: new WeakSet(),\n  iframePropertiesToAbort: {\n    read: new Set(),\n    write: new Set()\n  },\n  abortedIframes: new WeakMap()\n});\n\nconst startsCapitalized = new RegExp(\"^[A-Z]\");\n\n// all default classes/namespaces that must be secured upfront when\n// the environment is not executing in an isolated world\nexport default new Proxy(new Map([\n  // custom environment variables\n  [\"chrome\", (\n    isExtensionContext && (\n      (isChrome && chrome) ||\n      (isOtherThanChrome && browser)\n    )\n  ) || void 0],\n  [\"isExtensionContext\", isExtensionContext],\n  [\"variables\", variables],\n  // secured references and classes\n  [\"console\", copyIfExtension(console)],\n  [\"document\", globalThis.document],\n  [\"performance\", copyIfExtension(performance)],\n  [\"JSON\", copyIfExtension(JSON)],\n  [\"Map\", Map],\n  [\"Math\", copyIfExtension(Math)],\n  [\"Number\", isExtensionContext ? Number : primitive(\"Number\")],\n  [\"RegExp\", RegExp],\n  [\"Set\", Set],\n  [\"String\", isExtensionContext ? String : primitive(\"String\")],\n  [\"WeakMap\", WeakMap],\n  [\"WeakSet\", WeakSet],\n  // no need to secure but it surely helps if we trust native references\n  [\"MouseEvent\", MouseEvent]\n]), {\n  get(map, key) {\n    if (map.has(key))\n      return map.get(key);\n\n    let value = globalThis[key];\n    if (typeof value === \"function\")\n      value = (startsCapitalized.test(key) ? classes : invokes)[key];\n\n    map.set(key, value);\n    return value;\n  },\n  has(map, key) {\n    return map.has(key);\n  }\n});\n","/*! (c) Andrea Giammarchi - ISC */\n\n// no-op WeakValue mock as WeakRef support is still too little\n// use https://github.com/WebReflection/weak-value#readme otherwise\nclass WeakValue {\n  has() { return false; }\n  set() {}\n}\n\nconst helpers = {WeakSet, WeakMap, WeakValue};\nconst {apply} = Reflect;\n\nexport default function (callback) {'use strict';\n  const {WeakSet, WeakMap, WeakValue} = (this || helpers);\n  const ws = new WeakSet;\n  const wm = new WeakMap;\n  const wv = new WeakValue;\n  return function (any) {\n    if (ws.has(any))\n      return any;\n\n    if (wm.has(any))\n      return wm.get(any);\n\n    if (wv.has(any))\n      return wv.get(any);\n\n    const value = apply(callback, this, arguments);\n    ws.add(value);\n    if (value !== any)\n      (typeof any === 'object' && any ? wm : wv).set(any, value);\n    return value;\n  };\n};\n","// this is required by $ so it cannot be \"magic\" or circular dependency happens\nimport env from \"./env.js\";\nimport transformOnce from \"transform-once\";\n\nconst {Map, WeakMap, WeakSet, setTimeout} = env;\n\nlet cleanup = true;\nlet cleanUpCallback = map => {\n  map.clear();\n  cleanup = !cleanup;\n};\n\nexport default transformOnce.bind({\n  WeakMap,\n  WeakSet,\n  // this allows multiple $(primitives) and it cleans references later on\n  // basically a WeakRef implementation based on a single, shared, timer\n  WeakValue: class extends Map {\n    set(key, value) {\n      if (cleanup) {\n        cleanup = !cleanup;\n        setTimeout(cleanUpCallback, 0, this);\n      }\n      return super.set(key, value);\n    }\n  }\n});\n","import {caller} from './function.js';\n\nconst {concat, includes, join, reduce, unshift} = caller([]);\nexport {concat, includes, join, reduce, unshift};\n","import {secure} from './secure.js';\n\nconst {Map, WeakMap} = secure(globalThis);\nexport {Map, WeakMap};\n","import {apply, bind, call} from './function.js';\nimport {assign, getOwnPropertyDescriptors, getPrototypeOf} from './object.js';\nimport {unshift} from './array.js';\nimport {Map} from './globals.js';\n\nconst map = new Map;\nconst descriptors = target => {\n  const chain = [];\n  let current = target;\n  while (current) {\n    if (map.has(current))\n      unshift(chain, map.get(current));\n    else {\n      const descriptors = getOwnPropertyDescriptors(current);\n      map.set(current, descriptors);\n      unshift(chain, descriptors);\n    }\n    current = getPrototypeOf(current);\n  }\n  unshift(chain, {});\n  return apply(assign, null, chain);\n};\n\nexport const chain = source => {\n  const target = typeof source === 'function' ? source.prototype : source;\n  const chained = descriptors(target);\n  const handler = {\n    get(target, key) {\n      if (key in chained) {\n        const {value, get} = chained[key];\n        if (get)\n          return call(get, target);\n        if (typeof value === 'function')\n          return bind(value, target);\n      }\n      return target[key];\n    },\n    set(target, key, value) {\n      if (key in chained) {\n        const {set} = chained[key];\n        if (set) {\n          call(set, target, value);\n          return true;\n        }\n      }\n      target[key] = value;\n      return true;\n    }\n  };\n  return target => new Proxy(target, handler);\n};\n","/* global chrome, browser, globalThis */\n\nimport env from \"./utils/env.js\";\nimport transformer from \"./utils/transformer.js\";\nimport {call} from \"proxy-pants/function\";\nimport {chain} from \"proxy-pants/chain\";\n\nconst {\n  isExtensionContext,\n  Array,\n  Number,\n  String,\n  Object\n} = env;\n\nconst {isArray} = Array;\nconst {getOwnPropertyDescriptor, setPrototypeOf} = Object;\n\nconst {toString} = Object.prototype;\nconst {slice} = String.prototype;\nconst getBrand = value => call(slice, call(toString, value), 8, -1);\n\nconst {get: nodeType} = getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n\n// the main difference between secured classes and chained prototypes\n// is that chained values are not something we construct at all, it's\n// something we deal with instead, so that proxies are a better option,\n// or better, are less obtrusive if their proxy don't leak in the wild.\nconst chained = isExtensionContext ? {} : {\n  Attr: chain(Attr),\n  CanvasRenderingContext2D: chain(CanvasRenderingContext2D),\n  CSSStyleDeclaration: chain(CSSStyleDeclaration),\n  Document: chain(Document),\n  Element: chain(Element),\n  HTMLCanvasElement: chain(HTMLCanvasElement),\n  HTMLElement: chain(HTMLElement),\n  HTMLImageElement: chain(HTMLImageElement),\n  HTMLScriptElement: chain(HTMLScriptElement),\n  MutationRecord: chain(MutationRecord),\n  Node: chain(Node),\n  ShadowRoot: chain(ShadowRoot),\n\n  // this is some test env shenanigan\n  get CSS2Properties() {\n    return chained.CSSStyleDeclaration;\n  }\n};\n\nconst upgrade = (value, hint) => {\n  if (hint !== \"Element\" && hint in chained)\n    return chained[hint](value);\n\n  if (isArray(value))\n    return setPrototypeOf(value, Array.prototype);\n\n  const brand = getBrand(value);\n  if (brand in chained)\n    return chained[brand](value);\n\n  if (brand in env)\n    return setPrototypeOf(value, env[brand].prototype);\n\n  if (\"nodeType\" in value) {\n    switch (call(nodeType, value)) {\n      case 1:\n        if (!(hint in chained))\n          throw new Error(\"unknown hint \" + hint);\n        return chained[hint](value);\n      case 2:\n        return chained.Attr(value);\n      case 3:\n        return chained.Node(value);\n      case 9:\n        return chained.Document(value);\n    }\n  }\n\n  throw new Error(\"unknown brand \" + brand);\n};\n\n/* eslint valid-jsdoc: 0 */\n/** @type {<T>(t:T)=>t} Any value that can be upgraded or wrapped */\nexport default isExtensionContext ?\n  value => (value === window || value === globalThis ? env : value) :\n  transformer((value, hint = \"Element\") => {\n    if (value === window || value === globalThis)\n      return env;\n\n    switch (typeof value) {\n      case \"object\":\n        return value && upgrade(value, hint);\n\n      case \"string\":\n        return new String(value);\n\n      case \"number\":\n        return new Number(value);\n\n      default:\n        throw new Error(\"unsupported value\");\n    }\n  });\n","/* global checkElement:readonly */\n\nimport $ from \"../$.js\";\nimport {apply, bind} from \"proxy-pants/function\";\n\nimport {libEnvironment} from \"../environment.js\";\n\nlet {\n  document,\n  getComputedStyle,\n  isExtensionContext,\n  variables,\n  Array,\n  MutationObserver,\n  Object,\n  XPathEvaluator,\n  XPathExpression,\n  XPathResult\n} = $(window);\n\n// ensures that $$ is bound only in environments where document exists\nlet {querySelectorAll} = document;\nexport let $$ = querySelectorAll && bind(querySelectorAll, document);\n\n// make `new XPathExpression()` operations safe\nconst {assign, setPrototypeOf} = Object;\n\nclass $XPathExpression extends XPathExpression {\n  evaluate(...args) {\n    return setPrototypeOf(\n      apply(super.evaluate, this, args),\n      XPathResult.prototype\n    );\n  }\n}\n\nclass $XPathEvaluator extends XPathEvaluator {\n  createExpression(...args) {\n    return setPrototypeOf(\n      apply(super.createExpression, this, args),\n      $XPathExpression.prototype\n    );\n  }\n}\n\n/**\n * Hides an HTML element by setting its `style` attribute to\n * `display: none !important`.\n *\n * @param {HTMLElement} element The HTML element to hide.\n * @private\n */\nexport function hideElement(element) {\n  if (variables.hidden.has(element))\n    return;\n\n  notifyElementHidden(element);\n\n  variables.hidden.add(element);\n\n  let {style} = $(element);\n  let $style = $(style, \"CSSStyleDeclaration\");\n  let properties = $([]);\n  let {debugCSSProperties} = libEnvironment;\n\n  for (let [key, value] of (debugCSSProperties || [[\"display\", \"none\"]])) {\n    $style.setProperty(key, value, \"important\");\n    properties.push([key, $style.getPropertyValue(key)]);\n  }\n\n  // Listen for changes to the style property and if our values are unset\n  // then reset them.\n  new MutationObserver(() => {\n    for (let [key, value] of properties) {\n      let propertyValue = $style.getPropertyValue(key);\n      let propertyPriority = $style.getPropertyPriority(key);\n      if (propertyValue != value || propertyPriority != \"important\")\n        $style.setProperty(key, value, \"important\");\n    }\n  }).observe(element, {attributes: true,\n                       attributeFilter: [\"style\"]});\n}\n\n/**\n * Notifies the current contentScript that a new element has been hidden.\n * This is done by calling the globally available `checkElement` function\n * and passing the element.\n *\n * @param {HTMLElement} element The HTML element that was hidden.\n * @private\n */\nfunction notifyElementHidden(element) {\n  if (isExtensionContext && typeof checkElement === \"function\")\n    checkElement(element);\n}\n\n/**\n * A callback function to be applied to a node.\n * @callback queryAndApplyCallback\n * @param {Node} node\n * @private\n */\n\n/**\n * The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @callback queryAndApply\n * @param {queryAndApplyCallback} cb\n * @private\n */\n\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAndApply} The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @private\n */\nexport function initQueryAndApply(selector) {\n  let $selector = selector;\n  if ($selector.startsWith(\"xpath(\") &&\n      $selector.endsWith(\")\")) {\n    let xpathQuery = $selector.slice(6, -1);\n    let evaluator = new $XPathEvaluator();\n    let expression = evaluator.createExpression(xpathQuery, null);\n    // do not use ORDERED_NODE_ITERATOR_TYPE or the test env will fail\n    let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;\n\n    return cb => {\n      if (!cb)\n        return;\n      let result = expression.evaluate(document, flag, null);\n      let {snapshotLength} = result;\n      for (let i = 0; i < snapshotLength; i++)\n        cb(result.snapshotItem(i));\n    };\n  }\n  return cb => $$(selector).forEach(cb);\n}\n\n/**\n * The query function. Retrieves all the nodes in the DOM matching the\n * provided selector.\n * @callback queryAll\n * @returns {Node[]} An array containing all the nodes in the DOM matching\n * the provided selector.\n * @private\n */\n\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAll} The query function. Retrieves all the nodes in the DOM\n * matching the provided selector.\n * @private\n */\nexport function initQueryAll(selector) {\n  let $selector = selector;\n  if ($selector.startsWith(\"xpath(\") &&\n      $selector.endsWith(\")\")) {\n    let queryAndApply = initQueryAndApply(selector);\n    return () => {\n      let elements = $([]);\n      queryAndApply(e => elements.push(e));\n      return elements;\n    };\n  }\n  return () => Array.from($$(selector));\n}\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * it matches the provided condition.\n *\n * @param {function} match The function that provides the matching condition.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @returns {MutationObserver} Augmented MutationObserver object. It has a new\n *   function mo.race added to it. This can be used by the snippets to\n *   disconnect the MutationObserver with the racing mechanism.\n *   Used like: mo.race(raceWinner(() => {mo.disconnect();}));\n * @private\n */\nexport function hideIfMatches(match, selector, searchSelector) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let won;\n  const callback = () => {\n    for (const element of $$(searchSelector)) {\n      const closest = $(element).closest(selector);\n      if (closest && match(element, closest)) {\n        won();\n        hideElement(closest);\n      }\n    }\n  };\n  return assign(\n    new MutationObserver(callback),\n    {\n      race(win) {\n        won = win;\n        this.observe(document, {childList: true,\n                                characterData: true,\n                                subtree: true});\n        callback();\n      }\n    }\n  );\n}\n\n/**\n * Check if an element is visible\n *\n * @param {Element} element The element to check visibility of.\n * @param {CSSStyleDeclaration} style The computed style of element.\n * @param {?Element} closest The closest parent to reach.\n * @return {bool} Whether the element is visible.\n * @private\n */\nexport function isVisible(element, style, closest) {\n  let $style = $(style, \"CSSStyleDeclaration\");\n  if ($style.getPropertyValue(\"display\") == \"none\")\n    return false;\n\n  let visibility = $style.getPropertyValue(\"visibility\");\n  if (visibility == \"hidden\" || visibility == \"collapse\")\n    return false;\n\n  if (!closest || element == closest)\n    return true;\n\n  let parent = $(element).parentElement;\n  if (!parent)\n    return true;\n\n  return isVisible(parent, getComputedStyle(parent), closest);\n}\n\n/**\n * Returns the value of the `cssText` property of the object returned by\n * `getComputedStyle` for the given element.\n *\n * If the value of the `cssText` property is blank, this function computes the\n * value out of the properties available in the object.\n *\n * @param {Element} element The element for which to get the computed CSS text.\n *\n * @returns {string} The computed CSS text.\n * @private\n */\nexport function getComputedCSSText(element) {\n  let style = getComputedStyle(element);\n  let {cssText} = style;\n\n  if (cssText)\n    return cssText;\n\n  for (let property of style)\n    cssText += `${property}: ${style[property]}; `;\n\n  return $(cssText).trim();\n}\n","import $ from \"../$.js\";\n\nimport {initQueryAndApply} from \"../utils/dom.js\";\n\nlet {\n  parseInt,\n  setTimeout,\n  Error,\n  MouseEvent,\n  MutationObserver,\n  WeakSet\n} = $(window);\n\n/**\n * Simulate a mouse event on the page.\n * @alias module:content/snippets.simulate-event-poc\n *\n * @param {string} event Pattern that matches the type(s) of event\n * we want to prevent. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {string} selector The CSS/Xpath selector that an HTML element must\n * match for the event to be triggered.\n * @param {?string} delay The delay between the moment when the node is inserted\n * and the moment when the event is dispatched.\n *\n * @since Adblock Plus 3.11.2\n */\nexport function simulateEvent(event, selector, delay = \"0\") {\n  if (!event)\n    throw new Error(\"[simulate-event snippet]: No event type provided.\");\n  if (!selector)\n    throw new Error(\"[simulate-event snippet]: No selector provided.\");\n\n  let queryAndApply = initQueryAndApply(selector);\n  let delayInMiliseconds = parseInt(delay, 10);\n  let dispatchedNodes = new WeakSet();\n\n  let observer = new MutationObserver(findNodesAndDispatchEvents);\n  observer.observe(document, {childList: true, subtree: true});\n  findNodesAndDispatchEvents();\n\n  function findNodesAndDispatchEvents() {\n    queryAndApply(node => {\n      if (!dispatchedNodes.has(node)) {\n        dispatchedNodes.add(node);\n        setTimeout(() => {\n          $(node).dispatchEvent(\n            new MouseEvent(event, {bubbles: true, cancelable: true})\n          );\n        }, delayInMiliseconds);\n      }\n    });\n  }\n}\n","import $ from \"../$.js\";\n\nlet {Math, RegExp} = $(window);\n\n/**\n * Escapes regular expression special characters in a string.\n *\n * The returned string may be passed to the `RegExp` constructor to match the\n * original string.\n *\n * @param {string} string The string in which to escape special characters.\n *\n * @returns {string} A new string with the special characters escaped.\n * @private\n */\nfunction regexEscape(string) {\n  return $(string).replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n/**\n * Converts a given pattern to a regular expression.\n *\n * @param {string} pattern The pattern to convert. If the pattern begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression. If the pattern begins with a slash (`/`) and it ends with a\n *   (`/i`), the text in between is treated as case insensitive regular\n *   expression; otherwise the pattern is treated as raw text.\n *\n * @returns {RegExp} A `RegExp` object based on the given pattern.\n * @private\n */\nexport function toRegExp(pattern) {\n  let {length} = pattern;\n\n  // regexp in /.../ slashes must have at least length of 2\n  if (length > 1 && pattern[0] === \"/\") {\n    let isCaseSensitive = pattern[length - 1] === \"/\";\n    // if not case sensitive, ensure it's not the string \"/i\" itself\n    if (isCaseSensitive || (length > 2 && $(pattern).endsWith(\"/i\"))) {\n      let args = [$(pattern).slice(1, isCaseSensitive ? -1 : -2)];\n      if (!isCaseSensitive)\n        args.push(\"i\");\n\n      return new RegExp(...args);\n    }\n  }\n\n  return new RegExp(regexEscape(pattern));\n}\n\n/**\n * Generates a random alphanumeric ID consisting of 6 base-36 digits\n * from the range 100000..zzzzzz (both inclusive).\n *\n * @returns {string} The random ID.\n * @private\n */\nexport function randomId() {\n  // 2176782336 is 36^6 which mean 6 chars [a-z0-9]\n  // 60466176 is 36^5\n  // 2176782336 - 60466176 = 2116316160. This ensure to always have 6\n  // chars even if Math.random() returns its minimum value 0.0\n  //\n  return $(Math.floor(Math.random() * 2116316160 + 60466176)).toString(36);\n}\n","/**\n * Whether debug mode is enabled.\n * @type {boolean}\n * @private\n */\nlet debugging = false;\n\n/**\n * Tells if the debug mode is inactive.\n * @memberOf module:content/snippets.debug\n * @returns {boolean}\n */\nexport function debug() {\n  return debugging;\n}\n\n/**\n * Enables debug mode.\n * @alias module:content/snippets.debug\n *\n * @example\n * example.com#$#debug; log 'Hello, world!'\n *\n * @since Adblock Plus 3.8\n */\nexport function setDebug() {\n  debugging = true;\n}\n","import $ from \"../$.js\";\nimport {bind} from \"proxy-pants/function\";\n\nimport {debug} from \"./debug.js\";\n\nconst {console} = $(window);\n\nexport const noop = () => {};\n\n/**\n * Logs its arguments to the console.\n *\n * This may be used for testing and debugging.\n *\n * @alias module:content/snippets.log\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */\nexport function log(...args) {\n  if (debug())\n    $(args).unshift(\"%c DEBUG\", \"font-weight: bold\");\n\n  console.log(...args);\n}\n\n/**\n * Returns a no-op if debugging mode is off, returns a bound log otherwise.\n * @param {string} name the debugger name (first logged value)\n * @returns {function} either a no-op function or the logger one\n */\nexport function getDebugger(name) {\n  return bind(debug() ? log : noop, null, name);\n}\n","import $ from \"../$.js\";\nimport {noop} from \"./log.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Array, Error, Map, parseInt} = $(window);\n\nlet stack = null;\nlet won = null;\n\n// #$#race start; thing1; thing2; race stop;\n\n/**\n * Delimits a race among filters, to be able to disable competing filters when\n * any of them \"wins the race\". `#$#race start; filter1; filter2; race end;`\n * @param {string} action either `start` or `stop` the race.\n * @param {string} winners the amount of possible race's winners: 1 by default.\n */\nexport function race(action, winners = \"1\") {\n  switch (action) {\n    case \"start\":\n      stack = {\n        winners: parseInt(winners, 10) || 1,\n        participants: new Map()\n      };\n      won = new Array();\n      break;\n    case \"end\":\n    case \"finish\":\n    case \"stop\":\n      stack = null;\n      for (let win of won)\n        win();\n      won = null;\n      break;\n    default:\n      throw new Error(`Invalid action: ${action}`);\n  }\n}\n\n/**\n * Returns a function that, when a race is happening, can mark a winner,\n * by invoking all callbacks passed for every other snippet that lost the race.\n * @param {string} name the snippet name that is racing.\n * @param {function} lose a callback that, once invoked, will stop the snippet.\n * @returns {function} a callback to invoke whenever a match happens.\n */\nexport function raceWinner(name, lose) {\n  // without races, every invoke is a noop\n  if (stack === null)\n    return noop;\n\n  // within races though, trap the current stack and winners because more than\n  // a race could be defined for the same domains / filters\n  let current = stack;\n  let {participants} = current;\n  participants.set(win, lose);\n\n  // return a function that, once invoked, becomes a noop every other time and\n  // also invokes every other functions in the race to stop them as loosers\n  return win;\n\n  function win() {\n    // make the noop case the fastest one for any further invoke\n    if (current.winners < 1)\n      return;\n\n    let debugLog = getDebugger(\"race\");\n    debugLog(`${name} won the race`);\n\n    // in case a snippet wins while the race is still happening, queue them all\n    // so that unknown racing snippets get a chance to be disabled later on.\n    // i.e. race start 2; winner1; looser2; winner3; looser4; race end;\n    if (current === stack) {\n      won.push(win);\n    }\n    else {\n      participants.delete(win);\n      if (--current.winners < 1) {\n        for (let looser of participants.values())\n          looser();\n\n        participants.clear();\n      }\n    }\n  }\n}\n","import $ from \"../$.js\";\n\nimport {hideIfMatches} from \"../utils/dom.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element contains a given string.\n * @alias module:content/snippets.hide-if-contains\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n *\n * @since Adblock Plus 3.3\n */\nexport function hideIfContains(search, selector = \"*\", searchSelector = null) {\n  let re = toRegExp(search);\n\n  const mo = hideIfMatches(element => re.test($(element).textContent),\n                           selector,\n                           searchSelector);\n  mo.race(raceWinner(\n    \"hide-if-contains\",\n    () => {\n      mo.disconnect();\n    }\n  ));\n}\n","import $ from \"../$.js\";\n\nimport {$$, getComputedCSSText, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {MutationObserver} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element contains a given string and, optionally, if\n * the element's computed style contains a given string.\n * @alias module:content/snippets.hide-if-contains-and-matches-style\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {string?} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {string?} [style] The string that the computed style of an HTML\n *   element matching `selector` must contain. If the string begins and ends\n *   with a slash (`/`), the text in between is treated as a regular\n *   expression.\n * @param {string?} [searchStyle] The string that the computed style of an HTML\n *   element matching `searchSelector` must contain. If the string begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression.\n *\n * @since Adblock Plus 3.3.2\n */\nexport function hideIfContainsAndMatchesStyle(\n  search,\n  selector = \"*\",\n  searchSelector = null,\n  style = null,\n  searchStyle = null\n) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let searchRegExp = toRegExp(search);\n\n  let styleRegExp = style ? toRegExp(style) : null;\n  let searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;\n\n  let callback = () => {\n    for (let element of $$(searchSelector)) {\n      if (searchRegExp.test($(element).textContent) &&\n          (!searchStyleRegExp ||\n           searchStyleRegExp.test(getComputedCSSText(element)))) {\n        let closest = $(element).closest(selector);\n        if (closest && (!styleRegExp ||\n                        styleRegExp.test(getComputedCSSText(closest)))) {\n          win();\n          hideElement(closest);\n        }\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-contains-and-matches-style\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, characterData: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nimport {$$, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {\n  clearTimeout,\n  fetch,\n  getComputedStyle,\n  setTimeout,\n  Map,\n  MutationObserver,\n  Uint8Array\n} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the background image of the element matches a given pattern.\n * @alias module:content/snippets.hide-if-contains-image\n *\n * @param {string} search The pattern to look for in the background images of\n *   HTML elements. This must be the hexadecimal representation of the image\n *   data for which to look. If the string begins and ends with a slash (`/`),\n *   the text in between is treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given pattern must match. Defaults to the value of the\n *   `selector` argument.\n *\n * @since Adblock Plus 3.4.2\n */\nexport function hideIfContainsImage(search, selector, searchSelector) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let searchRegExp = toRegExp(search);\n\n  let callback = () => {\n    for (let element of $$(searchSelector)) {\n      let style = getComputedStyle(element);\n      let match = $(style[\"background-image\"]).match(/^url\\(\"(.*)\"\\)$/);\n      if (match) {\n        fetchContent(match[1]).then(content => {\n          if (searchRegExp.test(uint8ArrayToHex(new Uint8Array(content)))) {\n            let closest = $(element).closest(selector);\n            if (closest) {\n              win();\n              hideElement(closest);\n            }\n          }\n        });\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-contains-image\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, subtree: true});\n  callback();\n}\n\n\n/**\n * @typedef {object} FetchContentInfo\n * @property {function} remove\n * @property {Promise} result\n * @property {number} timer\n * @private\n */\n\n/**\n * @type {Map.<string, FetchContentInfo>}\n * @private\n */\nlet fetchContentMap = new Map();\n\n\n/**\n * Returns a potentially already resolved fetch auto cleaning, if not requested\n * again, after a certain amount of milliseconds.\n *\n * The resolved fetch is by default `arrayBuffer` but it can be any other kind\n * through the configuration object.\n *\n * @param {string} url The url to fetch\n * @param {object} [options] Optional configuration options.\n *                            By default is {as: \"arrayBuffer\", cleanup: 60000}\n * @param {string} [options.as] The fetch type: \"arrayBuffer\", \"json\", \"text\"..\n * @param {number} [options.cleanup] The cache auto-cleanup delay in ms: 60000\n *\n * @returns {Promise} The fetched result as Uint8Array|string.\n *\n * @example\n * fetchContent('https://any.url.com').then(arrayBuffer => { ... })\n * @example\n * fetchContent('https://a.com', {as: 'json'}).then(json => { ... })\n * @example\n * fetchContent('https://a.com', {as: 'text'}).then(text => { ... })\n * @private\n */\nfunction fetchContent(url, {as = \"arrayBuffer\", cleanup = 60000} = {}) {\n  // make sure the fetch type is unique as the url fetching text or arrayBuffer\n  // will fetch same url twice but it will resolve it as expected instead of\n  // keeping the fetch potentially hanging forever.\n  let uid = as + \":\" + url;\n  let details = fetchContentMap.get(uid) || {\n    remove: () => fetchContentMap.delete(uid),\n    result: null,\n    timer: 0\n  };\n  clearTimeout(details.timer);\n  details.timer = setTimeout(details.remove, cleanup);\n  if (!details.result) {\n    details.result = fetch(url).then(res => res[as]()).catch(details.remove);\n    fetchContentMap.set(uid, details);\n  }\n  return details.result;\n}\n\n/**\n * Converts a number to its hexadecimal representation.\n *\n * @param {number} number The number to convert.\n * @param {number} [length] The <em>minimum</em> length of the hexadecimal\n *   representation. For example, given the number `1024` and the length `8`,\n *   the function returns the value `\"00000400\"`.\n *\n * @returns {string} The hexadecimal representation of the given number.\n * @private\n */\nfunction toHex(number, length = 2) {\n  let hex = $(number).toString(16);\n\n  if (hex.length < length)\n    hex = $(\"0\").repeat(length - hex.length) + hex;\n\n  return hex;\n}\n\n/**\n * Converts a `Uint8Array` object into its hexadecimal representation.\n *\n * @param {Uint8Array} uint8Array The `Uint8Array` object to convert.\n *\n * @returns {string} The hexadecimal representation of the given `Uint8Array`\n *   object.\n * @private\n */\nfunction uint8ArrayToHex(uint8Array) {\n  return uint8Array.reduce((hex, byte) => hex + toHex(byte), \"\");\n}\n","import $ from \"../$.js\";\n\nimport {hideIfMatches, isVisible} from \"../utils/dom.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {log} from \"../introspection/log.js\";\nimport {debug} from \"../introspection/debug.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\nlet {getComputedStyle, Map, WeakSet, parseFloat} = $(window);\n\nconst {ELEMENT_NODE, TEXT_NODE} = Node;\n\n/**\n * Hides any HTML element matching a CSS selector if the visible text content\n * of the element contains a given string.\n * @alias module:content/snippets.hide-if-contains-visible-text\n *\n * @param {string} search The string to match to the visible text. Is considered\n *   visible text that isn't hidden by CSS properties or other means.\n *   If the string begins and ends with a slash (`/`), the text in between is\n *   treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {?Array.<string>} [attributes] The CSS attributes a computed style\n *   map of a node should have in order to consider that node hidden.\n *   Syntax: <key>:<value>, where <value> can be a string or a regex (if it\n *   starts and ends with a `/`).\n *\n * @since Adblock Plus 3.11.4\n */\nexport function hideIfContainsVisibleText(search, selector,\n                                          searchSelector = null,\n                                          ...attributes) {\n  let entries = $([]);\n  const optionalParameters = new Map([\n    [\"-snippet-box-margin\", \"2\"]\n  ]);\n\n  for (let attr of attributes) {\n    attr = $(attr);\n    let markerIndex = attr.indexOf(\":\");\n    if (markerIndex < 0)\n      continue;\n\n    let key = attr.slice(0, markerIndex).trim().toString();\n    let value = attr.slice(markerIndex + 1).trim().toString();\n\n    if (key && value) {\n      if (optionalParameters.has(key))\n        optionalParameters.set(key, value);\n      else\n        entries.push([key, value]);\n    }\n  }\n\n  let defaultEntries = $([\n    [\"opacity\", \"0\"],\n    [\"font-size\", \"0px\"],\n    // if color is transparent...\n    [\"color\", \"rgba(0, 0, 0, 0)\"]\n  ]);\n\n  let attributesMap = new Map(defaultEntries.concat(entries));\n\n  /**\n   * Determines if the text inside the element is visible.\n   *\n   * @param {Element} element The element we are checking.\n   * @param {?CSSStyleDeclaration} style The computed style of element. If\n   *   falsey it will be queried.\n   * @returns {bool} Whether the text is visible.\n   * @private\n   */\n  function isTextVisible(element, style) {\n    if (!style)\n      style = getComputedStyle(element);\n\n    style = $(style);\n\n    for (const [key, value] of attributesMap) {\n      let valueAsRegex = toRegExp(value);\n      if (valueAsRegex.test(style.getPropertyValue(key)))\n        return false;\n    }\n\n    let color = style.getPropertyValue(\"color\");\n    if (style.getPropertyValue(\"background-color\") == color)\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Check if a pseudo element has visible text via `content`.\n   *\n   * @param {Element} element The element to check visibility of.\n   * @param {string} pseudo The `::before` or `::after` pseudo selector.\n   * @return {string} The pseudo content or an empty string.\n   * @private\n   */\n  function getPseudoContent(element, pseudo) {\n    let style = getComputedStyle(element, pseudo);\n    if (!isVisible(element, style) || !isTextVisible(element, style))\n      return \"\";\n\n    let {content} = $(style);\n    if (content && content !== \"none\") {\n      let strings = $([]);\n\n      // remove all strings, in quotes, including escaping chars, putting\n      // instead `\\x01${string-index}` in place, which is not valid CSS,\n      // so that it's safe to parse it back at the end of the operation.\n      content = $(content).trim().replace(\n        /([\"'])(?:(?=(\\\\?))\\2.)*?\\1/g,\n        value => `\\x01${strings.push($(value).slice(1, -1)) - 1}`\n      );\n\n      // replace attr(...) with the attribute value or an empty string,\n      // ignoring units and fallback values, as these do not work, or have,\n      // any meaning in the CSS `content` property value.\n      content = content.replace(\n        /\\s*attr\\(\\s*([^\\s,)]+)[^)]*?\\)\\s*/g,\n        (_, name) => $(element).getAttribute(name) || \"\"\n      );\n\n      // replace back all `\\x01${string-index}` values with their corresponding\n      // strings, so that the outcome is a real, cleaned up, `content` value.\n      return content.replace(\n        /\\x01(\\d+)/g,\n        (_, index) => strings[index]);\n    }\n    return \"\";\n  }\n\n  /**\n   * Checks if child element is 100% included in the parent element.\n   *\n   * @param {Element} childNode\n   * @param {Element} parentNode\n   * @param {Object?} conf\n   * @param {Number?} conf.boxMargin\n   * @returns {boolean}\n   */\n  function isContained(childNode, parentNode, {boxMargin = 2} = {}) {\n    const child = $(childNode).getBoundingClientRect();\n    const parent = $(parentNode).getBoundingClientRect();\n    const stretchedParent = {\n      left: parent.left - boxMargin,\n      right: parent.right + boxMargin,\n      top: parent.top - boxMargin,\n      bottom: parent.bottom + boxMargin\n    };\n    return (\n      (stretchedParent.left <= child.left &&\n         child.left <= stretchedParent.right &&\n        stretchedParent.top <= child.top &&\n         child.top <= stretchedParent.bottom) &&\n      (stretchedParent.top <= child.bottom &&\n         child.bottom <= stretchedParent.bottom &&\n        stretchedParent.left <= child.right &&\n         child.right <= stretchedParent.right)\n    );\n  }\n\n  /**\n   * Returns the visible text content from an element and its descendants.\n   *\n   * @param {Element} element The element whose visible text we want.\n   * @param {Element} closest The closest parent to reach while checking\n   *   for visibility.\n   * @param {?CSSStyleDeclaration} style The computed style of element. If\n   *   falsey it will be queried.\n   * @param {Element} parentOverflowNode The closest parent with overflow hidden\n   * @param {?Object} conf Configuration object\n   * @param {?Number} conf.boxMargin The optional parameter that\n   *   can be used to specify how much to stretch the bounding box of the\n   *   overflow parent in pixels. Used to counter the hiding methods that\n   *   involve pushing decoy elements outside an overflow-y:hidden parent\n   *   to make them invisible. Default is 2 pixels.\n   * @returns {string} The text that is visible.\n   * @private\n   */\n  function getVisibleContent(element,\n                             closest,\n                             style,\n                             parentOverflowNode,\n                             {boxMargin = 2} = {}) {\n    let checkClosest = !style;\n    if (checkClosest)\n      style = getComputedStyle(element);\n\n    if (!isVisible(element, style, checkClosest && closest))\n      return \"\";\n\n    if (!parentOverflowNode &&\n      (\n        $(style).getPropertyValue(\"overflow-x\") === \"hidden\" ||\n        $(style).getPropertyValue(\"overflow-y\") === \"hidden\"\n      )\n    )\n      parentOverflowNode = element;\n\n    let text = getPseudoContent(element, \":before\");\n    for (let node of $(element).childNodes) {\n      switch ($(node).nodeType) {\n        case ELEMENT_NODE:\n          text += getVisibleContent(node,\n                                    element,\n                                    getComputedStyle(node),\n                                    parentOverflowNode,\n                                    {boxMargin});\n          break;\n        case TEXT_NODE:\n          // If there is a parent with overflow:hidden, it is possible to push\n          // elements out of the boundary box of that parent to make them\n          // invisible. This clause checks against that. We fallback to the\n          // current behaviour if no overflow parent.\n          if (parentOverflowNode) {\n            if (isContained(element, parentOverflowNode, {boxMargin}) &&\n              isTextVisible(element, style))\n              text += $(node).nodeValue;\n          }\n          else if (isTextVisible(element, style)) {\n            text += $(node).nodeValue;\n          }\n          break;\n      }\n    }\n    return text + getPseudoContent(element, \":after\");\n  }\n  const boxMarginStr = optionalParameters.get(\"-snippet-box-margin\");\n  const boxMargin = parseFloat(boxMarginStr) || 0;\n\n  let re = toRegExp(search);\n  let seen = new WeakSet();\n\n  const mo = hideIfMatches(\n    (element, closest) => {\n      if (seen.has(element))\n        return false;\n\n      seen.add(element);\n      let text = getVisibleContent(element, closest, null, null, {boxMargin});\n      let result = re.test(text);\n      if (debug() && text.length)\n        log(result, re, text);\n      return result;\n    },\n    selector,\n    searchSelector\n  );\n  mo.race(raceWinner(\n    \"hide-if-contains-visible-text\",\n    () => {\n      mo.disconnect();\n    }\n  ));\n}\n","import $ from \"../$.js\";\n\nimport {$$, getComputedCSSText, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {MutationObserver} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if a\n * descendant of the element matches a given CSS selector and, optionally, if\n * the element's computed style contains a given string.\n * @alias module:content/snippets.hide-if-has-and-matches-style\n *\n * @param {string} search The CSS selector against which to match the\n *   descendants of HTML elements.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the specified descendants must match. Defaults to the value of\n *   the `selector` argument.\n * @param {?string} [style] The string that the computed style of an HTML\n *   element matching `selector` must contain. If the string begins and ends\n *   with a slash (`/`), the text in between is treated as a regular\n *   expression.\n * @param {?string} [searchStyle] The string that the computed style of an HTML\n *   element matching `searchSelector` must contain. If the string begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression.\n *\n * @since Adblock Plus 3.4.2\n */\nexport function hideIfHasAndMatchesStyle(search, selector = \"*\",\n                                         searchSelector = null, style = null,\n                                         searchStyle = null) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let styleRegExp = style ? toRegExp(style) : null;\n  let searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;\n\n  let callback = () => {\n    for (let element of $$(searchSelector)) {\n      if ($(element).querySelector(search) &&\n          (!searchStyleRegExp ||\n           searchStyleRegExp.test(getComputedCSSText(element)))) {\n        let closest = $(element).closest(selector);\n        if (closest && (!styleRegExp ||\n                        styleRegExp.test(getComputedCSSText(closest)))) {\n          win();\n          hideElement(closest);\n        }\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-has-and-matches-style\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nimport {$$, hideElement, isVisible} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {getComputedStyle, MutationObserver, WeakSet} = $(window);\n\n/**\n * Hides any HTML element that uses an `aria-labelledby`, or one of its\n * ancestors, if the related aria element contains the searched text.\n * @alias module:content/snippets.hide-if-labelled-by\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector of an HTML element that uses as\n *   `aria-labelledby` attribute.\n * @param {?string} [searchSelector] The CSS selector of an ancestor of the\n *   HTML element that uses as `aria-labelledby` attribute. Defaults to the\n *   value of the `selector` argument.\n *\n * @since Adblock Plus 3.9\n */\nexport function hideIfLabelledBy(search, selector, searchSelector = null) {\n  let sameSelector = searchSelector == null;\n\n  let searchRegExp = toRegExp(search);\n\n  let matched = new WeakSet();\n\n  let callback = () => {\n    for (let node of $$(selector)) {\n      let closest = sameSelector ?\n                    node :\n                    $(node).closest(searchSelector);\n      if (!closest || !isVisible(node, getComputedStyle(node), closest))\n        continue;\n\n      let attr = $(node).getAttribute(\"aria-labelledby\");\n      let fallback = () => {\n        if (matched.has(closest))\n          return;\n\n        if (searchRegExp.test(\n          $(node).getAttribute(\"aria-label\") || \"\"\n        )) {\n          win();\n          matched.add(closest);\n          hideElement(closest);\n        }\n      };\n\n      if (attr) {\n        for (let label of $(attr).split(/\\s+/)) {\n          let target = $(document).getElementById(label);\n          if (target) {\n            if (!matched.has(target) && searchRegExp.test(target.innerText)) {\n              win();\n              matched.add(target);\n              hideElement(closest);\n            }\n          }\n          else {\n            fallback();\n          }\n        }\n      }\n      else {\n        fallback();\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-labelled-by\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {characterData: true, childList: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nlet {Math, setInterval, chrome, isExtensionContext, performance} = $(window);\n\n/**\n * Default profile(\"...\") returned object when profile mode is disabled.\n * @type {Profiler}\n * @private\n */\nconst noopProfile = {\n  mark() {},\n  end() {},\n  toString() {\n    return \"{mark(){},end(){}}\";\n  }\n};\n\n/**\n * Whether profile mode is inactive.\n * @type {boolean}\n * @private\n */\nlet inactive = true;\n\n/**\n * Tells if the profile is inactive.\n * @memberOf module:content/snippets.profile\n * @returns {boolean}\n */\nexport function inactiveProfile() {\n  return inactive;\n}\n\n/**\n * Enables profile mode.\n * @alias module:content/snippets.profile\n * @since Adblock Plus 3.9\n *\n * @example\n * example.com#$#profile; log 'Hello, world!'\n */\nexport function setProfile() {\n  inactive = false;\n}\n\n/**\n * @typedef {object} Profiler\n * @property {function} mark Add a `performance.mark(uniqueId)` entry.\n * @property {function} end Measure and clear `uniqueId` related marks. If a\n * `true` value is passed as argument, clear related interval and process all\n * collected samples since the creation of the profiler.\n * @private\n */\n\n/**\n * Create an object with `mark()` and `end()` methods to either keep marking a\n * specific profiled name, or ending it.\n *\n * @example\n * let {mark, end} = profile('console.log');\n * mark();\n * console.log(1, 2, 3);\n * end();\n *\n * @param {string} id the callback name or unique ID to profile.\n * @param {number} [rate] The number of times per minute to process samples.\n * @returns {Profiler} The profiler with `mark()` and `end(clear = false)`\n * methods.\n * @private\n */\nexport function profile(id, rate = 10) {\n  if (inactive || !isExtensionContext)\n    return noopProfile;\n\n  function processSamples() {\n    let samples = $([]);\n\n    for (let {name, duration} of performance.getEntriesByType(\"measure\"))\n      samples.push({name, duration});\n\n    if (samples.length) {\n      performance.clearMeasures();\n\n      chrome.runtime.sendMessage({\n        type: \"ewe:profiler.sample\",\n        category: \"snippets\",\n        samples\n      });\n    }\n  }\n\n  // avoid creation of N intervals when the same id is used\n  // over and over (i.e. within loops or multiple profile calls)\n  if (!profile[id]) {\n    profile[id] = setInterval(processSamples,\n                              Math.round(60000 / Math.min(60, rate)));\n  }\n\n  return {\n    mark() {\n      performance.mark(id);\n    },\n    end(clear = false) {\n      performance.measure(id, id);\n      performance.clearMarks(id);\n      if (clear) {\n        clearInterval(profile[id]);\n        delete profile[id];\n        processSamples();\n      }\n    }\n  };\n}\n","import $ from \"../$.js\";\n\nimport {hideElement, initQueryAndApply} from \"../utils/dom.js\";\nimport {profile} from \"../introspection/profile.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\nlet {MutationObserver} = $(window);\n\nconst {ELEMENT_NODE} = Node;\n\n/**\n * Hide a specific element through a XPath 1.0 query string.\n * See {@tutorial xpath-filters} to know more.\n * @alias module:content/snippets.hide-if-matches-xpath\n *\n * @param {string} query The XPath query that targets the element to hide.\n *\n * @since Adblock Plus 3.9.0\n */\nexport function hideIfMatchesXPath(query) {\n  let {mark, end} = profile(\"hide-if-matches-xpath\");\n\n  let queryAndApply = initQueryAndApply(`xpath(${query})`);\n\n  let callback = () => {\n    mark();\n\n    queryAndApply(node => {\n      win();\n      if ($(node).nodeType === ELEMENT_NODE)\n        hideElement(node);\n      else\n        $(node).textContent = \"\";\n    });\n\n    end();\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-matches-xpath\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {characterData: true, childList: true, subtree: true});\n  callback();\n}\n","import {Proxy} from './proxy.js';\nimport {apply, call} from './function.js';\nimport {\n  getOwnPropertyDescriptor,\n  getPrototypeOf,\n  hasOwnProperty\n} from './object.js';\n\nconst handler = {\n  get(target, name) {\n    const context = target;\n    while (!hasOwnProperty(target, name))\n      target = getPrototypeOf(target);\n    const {get, set} = getOwnPropertyDescriptor(target, name);\n    return function () {\n      return arguments.length ?\n              apply(set, context, arguments) :\n              call(get, context);\n    };\n  }\n};\n\nexport const accessor = target => new Proxy(target, handler);\n","import $ from \"../$.js\";\nimport {accessor} from \"proxy-pants/accessor\";\nimport {apply, call} from \"proxy-pants/function\";\nimport {hasOwnProperty} from \"proxy-pants/object\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {randomId} from \"./general.js\";\n\nlet {\n  parseFloat,\n  variables,\n  Array,\n  Error,\n  Map,\n  Object,\n  ReferenceError,\n  Set,\n  WeakMap\n} = $(window);\n\nlet {onerror} = accessor(window);\n\nlet NodeProto = Node.prototype;\nlet ElementProto = Element.prototype;\n\nlet propertyAccessors = null;\n\nexport function wrapPropertyAccess(object, property, descriptor) {\n  let $property = $(property);\n  let dotIndex = $property.indexOf(\".\");\n  if (dotIndex == -1) {\n    // simple property case.\n    let currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n    if (currentDescriptor && !currentDescriptor.configurable)\n      return;\n\n    // Keep it configurable because the same property can be wrapped via\n    // multiple snippet filters (#7373).\n    let newDescriptor = Object.assign({}, descriptor, {\n      configurable: true\n    });\n\n    if (!currentDescriptor && !newDescriptor.get && newDescriptor.set) {\n      let propertyValue = object[property];\n      newDescriptor.get = () => propertyValue;\n    }\n\n    Object.defineProperty(object, property, newDescriptor);\n    return;\n  }\n\n  let name = $property.slice(0, dotIndex);\n  property = $property.slice(dotIndex + 1);\n  let value = object[name];\n  if (value && (typeof value == \"object\" || typeof value == \"function\"))\n    wrapPropertyAccess(value, property, descriptor);\n\n  let currentDescriptor = Object.getOwnPropertyDescriptor(object, name);\n  if (currentDescriptor && !currentDescriptor.configurable)\n    return;\n\n  // lazy initialization (reduced heap)\n  if (!propertyAccessors)\n    propertyAccessors = new WeakMap();\n\n  // allow branched properties that might not exist yet\n  if (!propertyAccessors.has(object))\n    propertyAccessors.set(object, new Map());\n\n  // if the name is already known, simply add the descriptor\n  // to the sub-brnach for the property\n  let properties = propertyAccessors.get(object);\n  if (properties.has(name)) {\n    properties.get(name).set(property, descriptor);\n    return;\n  }\n\n  // in every other case just create the branch and set\n  // the accessor only once for the very same name.\n  let toBeWrapped = new Map([[property, descriptor]]);\n  properties.set(name, toBeWrapped);\n  Object.defineProperty(object, name, {\n    get: () => value,\n    set(newValue) {\n      value = newValue;\n      if (value && (typeof value == \"object\" || typeof value == \"function\")) {\n        // loop through all branches to avoid loosing/overwriting previously\n        // set ones\n        for (let [prop, desc] of toBeWrapped)\n          wrapPropertyAccess(value, prop, desc);\n      }\n    },\n    configurable: true\n  });\n}\n\n/**\n * Overrides the `onerror` handler to discard tagged error messages from our\n * property wrapping.\n *\n * @param {string} magic The magic string that tags the error message.\n * @private\n */\nexport function overrideOnError(magic) {\n  let prev = onerror();\n  onerror((...args) => {\n    let message = args.length && args[0];\n    if (typeof message == \"string\" && $(message).includes(magic))\n      return true;\n    if (typeof prev == \"function\")\n      return apply(prev, this, args);\n  });\n}\n\n/**\n * Patches a property on the `context` object to abort execution when the\n * property is read.\n *\n * @param {string} loggingPrefix A string with which we prefix the logs.\n * @param {Window} context The window object whose property we patch.\n * @param {string} property The name of the property.\n * @private\n */\nexport function abortOnRead(loggingPrefix, context, property) {\n  let debugLog = getDebugger(loggingPrefix);\n\n  if (!property) {\n    debugLog(\"no property to abort on read\");\n    return;\n  }\n\n  let rid = randomId();\n\n  function abort() {\n    debugLog(`${property} access aborted`);\n    throw new ReferenceError(rid);\n  }\n\n  debugLog(`aborting on ${property} access`);\n\n  wrapPropertyAccess(context, property, {get: abort, set() {}});\n  overrideOnError(rid);\n}\n\n/**\n * Patches a property on the `context` object to abort execution when the\n * property is written.\n *\n * @param {string} loggingPrefix A string with which we prefix the logs.\n * @param {Window} context The window object whose property we patch.\n * @param {string} property The name of the property.\n * @private\n */\nexport function abortOnWrite(loggingPrefix, context, property) {\n  let debugLog = getDebugger(loggingPrefix);\n\n  if (!property) {\n    debugLog(\"no property to abort on write\");\n    return;\n  }\n\n  let rid = randomId();\n\n  function abort() {\n    debugLog(`setting ${property} aborted`);\n    throw new ReferenceError(rid);\n  }\n\n  debugLog(`aborting when setting ${property}`);\n\n  wrapPropertyAccess(context, property, {set: abort});\n  overrideOnError(rid);\n}\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is read/written.\n *\n * @param {...string} properties The list with the properties.\n * @param {boolean?} [abortRead=false] Should abort on read option.\n * @param {boolean?} [abortWrite=false] Should abort on write option.\n * @private\n */\nexport function abortOnIframe(\n  properties,\n  abortRead = false,\n  abortWrite = false\n) {\n  let abortedIframes = variables.abortedIframes;\n  let iframePropertiesToAbort = variables.iframePropertiesToAbort;\n\n  // add new properties-to-abort to all aborted iframes' WeakMaps\n  for (let frame of Array.from(window.frames)) {\n    if (abortedIframes.has(frame)) {\n      for (let property of properties) {\n        if (abortRead)\n          abortedIframes.get(frame).read.add(property);\n        if (abortWrite)\n          abortedIframes.get(frame).write.add(property);\n      }\n    }\n  }\n\n  // store properties-to-abort\n  for (let property of properties) {\n    if (abortRead)\n      iframePropertiesToAbort.read.add(property);\n    if (abortWrite)\n      iframePropertiesToAbort.write.add(property);\n  }\n\n  queryAndProxyIframe();\n  if (!abortedIframes.has(document)) {\n    abortedIframes.set(document, true);\n    addHooksOnDomAdditions(queryAndProxyIframe);\n  }\n\n  function queryAndProxyIframe() {\n    for (let frame of Array.from(window.frames)) {\n      // add WeakMap entry for every missing frame\n      if (!abortedIframes.has(frame)) {\n        abortedIframes.set(frame, {\n          read: new Set(iframePropertiesToAbort.read),\n          write: new Set(iframePropertiesToAbort.write)\n        });\n      }\n\n      let readProps = abortedIframes.get(frame).read;\n      if (readProps.size > 0) {\n        let props = Array.from(readProps);\n        readProps.clear();\n        for (let property of props)\n          abortOnRead(\"abort-on-iframe-property-read\", frame, property);\n      }\n\n      let writeProps = abortedIframes.get(frame).write;\n      if (writeProps.size > 0) {\n        let props = Array.from(writeProps);\n        writeProps.clear();\n        for (let property of props)\n          abortOnWrite(\"abort-on-iframe-property-write\", frame, property);\n      }\n    }\n  }\n}\n\n/**\n * Patches the native functions which are responsible with adding Nodes to DOM.\n * Adds a hook at right after the addition.\n *\n * @param {function} endCallback The list with the properties.\n * @private\n */\nfunction addHooksOnDomAdditions(endCallback) {\n  let descriptor;\n\n  wrapAccess(NodeProto, [\"appendChild\", \"insertBefore\", \"replaceChild\"]);\n  wrapAccess(ElementProto, [\"append\", \"prepend\", \"replaceWith\", \"after\",\n                            \"before\", \"insertAdjacentElement\",\n                            \"insertAdjacentHTML\"]);\n\n  descriptor = getInnerHTMLDescriptor(ElementProto, \"innerHTML\");\n  wrapPropertyAccess(ElementProto, \"innerHTML\", descriptor);\n\n  descriptor = getInnerHTMLDescriptor(ElementProto, \"outerHTML\");\n  wrapPropertyAccess(ElementProto, \"outerHTML\", descriptor);\n\n  function wrapAccess(prototype, names) {\n    for (let name of names) {\n      let desc = getAppendChildDescriptor(prototype, name);\n      wrapPropertyAccess(prototype, name, desc);\n    }\n  }\n\n  function getAppendChildDescriptor(target, property) {\n    let currentValue = target[property];\n    return {\n      get() {\n        return function(...args) {\n          let result;\n          result = apply(currentValue, this, args);\n          endCallback && endCallback();\n          return result;\n        };\n      }\n    };\n  }\n\n  function getInnerHTMLDescriptor(target, property) {\n    let desc = Object.getOwnPropertyDescriptor(target, property);\n    let {set: prevSetter} = desc || {};\n    return {\n      set(val) {\n        let result;\n        result = call(prevSetter, this, val);\n        endCallback && endCallback();\n        return result;\n      }\n    };\n  }\n}\n\nlet {Object: NativeObject} = window;\nexport function findOwner(root, path) {\n  if (!(root instanceof NativeObject))\n    return;\n\n  let object = root;\n  let chain = $(path).split(\".\");\n\n  if (chain.length === 0)\n    return;\n\n  for (let i = 0; i < chain.length - 1; i++) {\n    let prop = chain[i];\n    // eslint-disable-next-line no-prototype-builtins\n    if (!hasOwnProperty(object, prop))\n      return;\n\n    object = object[prop];\n\n    if (!(object instanceof NativeObject))\n      return;\n  }\n\n  let prop = chain[chain.length - 1];\n  // eslint-disable-next-line no-prototype-builtins\n  if (hasOwnProperty(object, prop))\n    return [object, prop];\n}\n\n// TBD: should this accept floating numbers too?\nconst decimals = $(/^\\d+$/);\n\nexport function overrideValue(value) {\n  switch (value) {\n    case \"false\":\n      return false;\n    case \"true\":\n      return true;\n    case \"null\":\n      return null;\n    case \"noopFunc\":\n      return () => {};\n    case \"trueFunc\":\n      return () => true;\n    case \"falseFunc\":\n      return () => false;\n    case \"emptyArray\":\n      return [];\n    case \"emptyObj\":\n      return {};\n    case \"undefined\":\n      return void 0;\n    case \"\":\n      return value;\n    default:\n      if (decimals.test(value))\n        return parseFloat(value);\n\n      throw new Error(\"[override-property-read snippet]: \" +\n                      `Value \"${value}\" is not valid.`);\n  }\n}\n","import $ from \"../$.js\";\nimport {call} from \"proxy-pants/function\";\n\nimport {overrideOnError, wrapPropertyAccess} from \"../utils/execution.js\";\nimport {randomId, toRegExp} from \"../utils/general.js\";\n\nlet {HTMLScriptElement, Object, ReferenceError} = $(window);\nlet Script = Object.getPrototypeOf(HTMLScriptElement);\n\n/**\n * Aborts the execution of an inline script.\n * @alias module:content/snippets.abort-current-inline-script\n *\n * @param {string} api API function or property name to anchor on.\n * @param {?string} [search] If specified, only scripts containing the given\n *   string are prevented from executing. If the string begins and ends with a\n *   slash (`/`), the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.4.3\n */\nexport function abortCurrentInlineScript(api, search = null) {\n  let re = search ? toRegExp(search) : null;\n\n  let rid = randomId();\n  let us = $(document).currentScript;\n\n  let object = window;\n  let path = $(api).split(\".\");\n  let name = $(path).pop();\n\n  for (let node of $(path)) {\n    object = object[node];\n\n    if (!object || !(typeof object == \"object\" || typeof object == \"function\"))\n      return;\n  }\n\n  let {get: prevGetter, set: prevSetter} =\n    Object.getOwnPropertyDescriptor(object, name) || {};\n\n  let currentValue = object[name];\n\n  let abort = () => {\n    let element = $(document).currentScript;\n    if (element instanceof Script &&\n        $(element, \"HTMLScriptElement\").src == \"\" &&\n        element != us &&\n        (!re || re.test($(element).textContent)))\n      throw new ReferenceError(rid);\n  };\n\n  let descriptor = {\n    get() {\n      abort();\n\n      if (prevGetter)\n        return call(prevGetter, this);\n\n      return currentValue;\n    },\n    set(value) {\n      abort();\n\n      if (prevSetter)\n        call(prevSetter, this, value);\n      else\n        currentValue = value;\n    }\n  };\n\n  wrapPropertyAccess(object, name, descriptor);\n\n  overrideOnError(rid);\n}\n","import {abortOnIframe} from \"../utils/execution.js\";\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is read.\n *\n * No error is printed to the console.\n * @alias module:content/snippets.abort-on-iframe-property-read\n *\n * @param {...string} properties The list with the properties.\n *\n * @since Adblock Plus 3.10.1\n */\nexport function abortOnIframePropertyRead(...properties) {\n  abortOnIframe(properties, true, false);\n}\n","import {abortOnIframe} from \"../utils/execution.js\";\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is written.\n *\n * No error is printed to the console.\n * @alias module:content/snippets.abort-on-iframe-property-write\n *\n * @param {...string} properties The list with the properties.\n *\n * @since Adblock Plus 3.10.1\n */\nexport function abortOnIframePropertyWrite(...properties) {\n  abortOnIframe(properties, false, true);\n}\n","import {abortOnRead} from \"../utils/execution.js\";\n\n/**\n * Patches a property on the window object to abort execution when the\n * property is read.\n *\n * No error is printed to the console.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L1703).\n * @alias module:content/snippets.abort-on-property-read\n *\n * @param {string} property The name of the property.\n *\n * @since Adblock Plus 3.4.1\n */\nexport function abortOnPropertyRead(property) {\n  abortOnRead(\"abort-on-property-read\", window, property);\n}\n","import {abortOnWrite} from \"../utils/execution.js\";\n\n/**\n * Patches a property on the window object to abort execution when the\n * property is written.\n *\n * No error is printed to the console.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L1671).\n * @alias module:content/snippets.abort-on-property-write\n *\n * @param {string} property The name of the property.\n *\n * @since Adblock Plus 3.4.3\n */\nexport function abortOnPropertyWrite(property) {\n  abortOnWrite(\"abort-on-property-write\", window, property);\n}\n","import $ from \"../$.js\";\nimport {accessor} from \"proxy-pants/accessor\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {Error} = $(window);\nlet {cookie: documentCookies} = accessor(document);\n\n/**\n * Removes a specific cookie by setting it's expiration date in the past.\n * @alias module:content/snippets.cookie-remover\n *\n * @param {string} cookie The name of the cookie that we want removed.\n * If the string begins and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.11.2\n */\nexport function cookieRemover(cookie) {\n  if (!cookie)\n    throw new Error(\"[cookie-remover snippet]: No cookie to remove.\");\n\n  let debugLog = getDebugger(\"cookie-remover\");\n  let re = toRegExp(cookie);\n\n  // In some cases, when the snippet is executed, the protocol is about:blank\n  // thus preventing us from actually removing the cookie.\n  if (!$(/^http|^about/).test(location.protocol)) {\n    debugLog(\"Snippet only works for http or https and about.\");\n    return;\n  }\n\n  debugLog(\"Parsing cookies for matches\");\n\n  for (const pair of $(getCookieMatches())) {\n    let $hostname = $(location.hostname);\n    let name = $(pair).split(\"=\")[0];\n    let expires = \"expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n    let path = \"path=/\";\n    let domain = \"domain=\" + $hostname.slice($hostname.indexOf(\".\") + 1);\n\n    documentCookies(`${$(name).trim()}=;${expires};${path};${domain}`);\n\n    debugLog(`Set expiration date on ${name}`);\n  }\n\n  function getCookieMatches() {\n    const arr = $(documentCookies()).split(\";\");\n    return arr.filter(str => re.test($(str).split(\"=\")[0]));\n  }\n}\n","import $ from \"../$.js\";\nimport {apply, call} from \"proxy-pants/function\";\n\nimport {log} from \"../introspection/log.js\";\nimport {debug} from \"../introspection/debug.js\";\nimport {hideElement, initQueryAll} from \"../utils/dom.js\";\nimport {wrapPropertyAccess} from \"../utils/execution.js\";\nimport {randomId, toRegExp} from \"../utils/general.js\";\n\n// These classes cannot be secured in a meaningful way because new nodes\n// would not use the secured prototype and the secured environment is obtained\n// though the chained counterpart of these classes. Because of this, it's OK to\n// just trap any value or prototype on the top of this file or in any other\n// file that needs global DOM classes constants or prototype. The `$(element)`\n// operation uses indeed chained version of these classes so that it's\n// transparent for the node and no prototype upgrade ever leaks in the wild.\nlet {ELEMENT_NODE, TEXT_NODE, prototype: NodeProto} = Node;\nlet {prototype: ElementProto} = Element;\nlet {prototype: HTMLElementProto} = HTMLElement;\n\nlet {\n  console,\n  variables,\n  DOMParser,\n  Error,\n  MutationObserver,\n  Object,\n  ReferenceError\n} = $(window);\n\nlet {getOwnPropertyDescriptor} = Object;\n\n/**\n * Freezes a DOM element so it prevents adding new nodes inside it.\n * @alias module:content/snippets.freeze-element\n *\n * @param {string} selector The CSS selector for the parent element that\n *   we want to freeze\n * @param {string?} [options] A single parameter for snippet's options.\n *   A string containing all the options we want to pass, each of them\n *   separated by a plus character (`+`). Empty single quotes if none (`''`).\n *   Available options:\n *   **subtree** (if we want to freeze all the element's children as well);\n *   **abort** (throw an error every time an child element gets added);\n * @param {string?} [exceptions] An array of regex/selectors used to specify\n *   the nodes we don't want to prevent being added.\n *   Each array item can be:\n *   **selector** (targeting Element nodes);\n *   **regex** (targeting Text nodes, identified by slash);\n *\n * @since Adblock Plus 3.9.5\n */\nexport function freezeElement(selector, options = \"\", ...exceptions) {\n  let observer;\n  let subtree = false;\n  let shouldAbort = false;\n  let exceptionSelectors = $(exceptions).filter(e => !isRegex(e));\n  let regexExceptions = $(exceptions).filter(e => isRegex(e)).map(toRegExp);\n  let rid = randomId();\n  let targetNodes;\n  let queryAll = initQueryAll(selector);\n\n  checkOptions();\n  let data = {\n    selector,\n    shouldAbort,\n    rid,\n    exceptionSelectors,\n    regexExceptions,\n    changeId: 0\n  };\n  if (!variables.frozen.has(document)) {\n    variables.frozen.set(document, true);\n    proxyNativeProperties();\n  }\n  observer = new MutationObserver(searchAndAttach);\n  observer.observe(document, {childList: true, subtree: true});\n  searchAndAttach();\n\n  function isRegex(s) {\n    return s.length >= 2 && s[0] == \"/\" && s[s.length - 1] == \"/\";\n  }\n\n  function checkOptions() {\n    let optionsChunks = $(options).split(\"+\");\n    if (optionsChunks.length === 1 && optionsChunks[0] === \"\")\n      optionsChunks = [];\n    for (let chunk of optionsChunks) {\n      switch (chunk) {\n        case \"subtree\":\n          subtree = true;\n          break;\n        case \"abort\":\n          shouldAbort = true;\n          break;\n        default:\n          throw new Error(\"[freeze] Unknown option passed to the snippet.\" +\n                          \" [selector]: \" + selector +\n                          \" [option]: \" + chunk);\n      }\n    }\n  }\n\n  function proxyNativeProperties() {\n    let descriptor;\n\n    descriptor = getAppendChildDescriptor(\n      NodeProto, \"appendChild\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"appendChild\", descriptor);\n\n    descriptor = getAppendChildDescriptor(\n      NodeProto, \"insertBefore\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"insertBefore\", descriptor);\n\n    descriptor = getAppendChildDescriptor(\n      NodeProto, \"replaceChild\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"replaceChild\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto, \"append\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(ElementProto, \"append\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto, \"prepend\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(ElementProto, \"prepend\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto,\n      \"replaceWith\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"replaceWith\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto,\n      \"after\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"after\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto,\n      \"before\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"before\", descriptor);\n\n    descriptor = getInsertAdjacentDescriptor(\n      ElementProto,\n      \"insertAdjacentElement\",\n      isFrozenAndInsideTarget,\n      getSnippetDataBasedOnTarget\n    );\n    wrapPropertyAccess(ElementProto, \"insertAdjacentElement\", descriptor);\n\n    descriptor = getInsertAdjacentDescriptor(\n      ElementProto,\n      \"insertAdjacentHTML\",\n      isFrozenAndInsideTarget,\n      getSnippetDataBasedOnTarget\n    );\n    wrapPropertyAccess(ElementProto, \"insertAdjacentHTML\", descriptor);\n\n    descriptor = getInsertAdjacentDescriptor(\n      ElementProto,\n      \"insertAdjacentText\",\n      isFrozenAndInsideTarget,\n      getSnippetDataBasedOnTarget\n    );\n    wrapPropertyAccess(ElementProto, \"insertAdjacentText\", descriptor);\n\n    descriptor = getInnerHTMLDescriptor(\n      ElementProto, \"innerHTML\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(ElementProto, \"innerHTML\", descriptor);\n\n    descriptor = getInnerHTMLDescriptor(\n      ElementProto,\n      \"outerHTML\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"outerHTML\", descriptor);\n\n    descriptor = getTextContentDescriptor(\n      NodeProto, \"textContent\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"textContent\", descriptor);\n\n    descriptor = getTextContentDescriptor(\n      HTMLElementProto, \"innerText\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(HTMLElementProto, \"innerText\", descriptor);\n\n    descriptor = getTextContentDescriptor(\n      NodeProto, \"nodeValue\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"nodeValue\", descriptor);\n\n    function isFrozen(node) {\n      return node && variables.frozen.has(node);\n    }\n\n    function isFrozenOrHasFrozenParent(node) {\n      try {\n        return node &&\n               (variables.frozen.has(node) ||\n               variables.frozen.has($(node).parentNode));\n      }\n      catch (error) {\n        return false;\n      }\n    }\n\n    function isFrozenAndInsideTarget(node, isInsideTarget) {\n      try {\n        return node &&\n               (variables.frozen.has(node) && isInsideTarget ||\n                variables.frozen.has($(node).parentNode) &&\n                !isInsideTarget);\n      }\n      catch (error) {\n        return false;\n      }\n    }\n\n    function getSnippetData(node) {\n      return variables.frozen.get(node);\n    }\n\n    function getSnippetDataFromNodeOrParent(node) {\n      try {\n        if (variables.frozen.has(node))\n          return variables.frozen.get(node);\n        let parent = $(node).parentNode;\n        return variables.frozen.get(parent);\n      }\n      catch (error) {}\n    }\n\n    function getSnippetDataBasedOnTarget(node, isInsideTarget) {\n      try {\n        if (variables.frozen.has(node) && isInsideTarget)\n          return variables.frozen.get(node);\n        let parent = $(node).parentNode;\n        return variables.frozen.get(parent);\n      }\n      catch (error) {}\n    }\n  }\n\n  function searchAndAttach() {\n    targetNodes = queryAll();\n    markNodes(targetNodes, false);\n  }\n\n  function markNodes(nodes, isChild = true) {\n    for (let node of nodes) {\n      if (!variables.frozen.has(node)) {\n        variables.frozen.set(node, data);\n        if (!isChild && subtree) {\n          new MutationObserver(mutationsList => {\n            for (let mutation of $(mutationsList))\n              markNodes($(mutation, \"MutationRecord\").addedNodes);\n          }).observe(node, {childList: true, subtree: true});\n        }\n        if (subtree && $(node).nodeType === ELEMENT_NODE)\n          markNodes($(node).childNodes);\n      }\n    }\n  }\n\n  // utilities\n  function logPrefixed(id, ...args) {\n    log(`[freeze][${id}] `, ...args);\n  }\n\n  function logChange(nodeOrDOMString, target, property, snippetData) {\n    let targetSelector = snippetData.selector;\n    let chgId = snippetData.changeId;\n    let isDOMString = typeof nodeOrDOMString == \"string\";\n    let action = snippetData.shouldAbort ? \"aborting\" : \"watching\";\n    console.groupCollapsed(`[freeze][${chgId}] ${action}: ${targetSelector}`);\n    switch (property) {\n      case \"appendChild\":\n      case \"append\":\n      case \"prepend\":\n      case \"insertBefore\":\n      case \"replaceChild\":\n      case \"insertAdjacentElement\":\n      case \"insertAdjacentHTML\":\n      case \"insertAdjacentText\":\n      case \"innerHTML\":\n      case \"outerHTML\":\n        logPrefixed(chgId,\n                    isDOMString ? \"text: \" : \"node: \",\n                    nodeOrDOMString);\n        logPrefixed(chgId, \"added to node: \", target);\n        break;\n      case \"replaceWith\":\n      case \"after\":\n      case \"before\":\n        logPrefixed(chgId,\n                    isDOMString ? \"text: \" : \"node: \",\n                    nodeOrDOMString);\n        logPrefixed(chgId, \"added to node: \", $(target).parentNode);\n        break;\n      case \"textContent\":\n      case \"innerText\":\n      case \"nodeValue\":\n        logPrefixed(chgId, \"content of node: \", target);\n        logPrefixed(chgId, \"changed to: \", nodeOrDOMString);\n        break;\n      default:\n        break;\n    }\n    logPrefixed(chgId, `using the function \"${property}\"`);\n    console.groupEnd();\n    snippetData.changeId++;\n  }\n\n  function isExceptionNode(element, expSelectors) {\n    if (expSelectors) {\n      let $element = $(element);\n      for (let exception of expSelectors) {\n        if ($element.matches(exception))\n          return true;\n      }\n    }\n    return false;\n  }\n\n  function isExceptionText(string, regExceptions) {\n    if (regExceptions) {\n      for (let exception of regExceptions) {\n        if (exception.test(string))\n          return true;\n      }\n    }\n    return false;\n  }\n\n  function abort(id) {\n    throw new ReferenceError(id);\n  }\n\n  // check inserted content\n  function checkHTML(htmlText, parent, property, snippetData) {\n    let domparser = new DOMParser();\n    let {body} = $(domparser.parseFromString(htmlText, \"text/html\"));\n    let nodes = $(body).childNodes;\n    let accepted = checkMultiple(nodes, parent, property, snippetData);\n    let content = $(accepted).map(node => {\n      switch ($(node).nodeType) {\n        case ELEMENT_NODE:\n          return $(node).outerHTML;\n        case TEXT_NODE:\n          return $(node).textContent;\n        default:\n          return \"\";\n      }\n    });\n    return content.join(\"\");\n  }\n\n  function checkMultiple(nodesOrDOMStrings, parent, property, snippetData) {\n    let accepted = $([]);\n    for (let nodeOrDOMString of nodesOrDOMStrings) {\n      if (checkShouldInsert(nodeOrDOMString, parent, property, snippetData))\n        accepted.push(nodeOrDOMString);\n    }\n    return accepted;\n  }\n\n  function checkShouldInsert(nodeOrDOMString, parent, property, snippetData) {\n    let aborting = snippetData.shouldAbort;\n    let regExceptions = snippetData.regexExceptions;\n    let expSelectors = snippetData.exceptionSelectors;\n    let id = snippetData.rid;\n    if (typeof nodeOrDOMString == \"string\") {\n      let domString = nodeOrDOMString;\n      if (isExceptionText(domString, regExceptions))\n        return true;\n      if (debug())\n        logChange(domString, parent, property, snippetData);\n      if (aborting)\n        abort(id);\n      return debug();\n    }\n\n    let node = nodeOrDOMString;\n    switch ($(node).nodeType) {\n      case ELEMENT_NODE:\n        if (isExceptionNode(node, expSelectors))\n          return true;\n        if (aborting) {\n          if (debug())\n            logChange(node, parent, property, snippetData);\n          abort(id);\n        }\n        if (debug()) {\n          hideElement(node);\n          logChange(node, parent, property, snippetData);\n          return true;\n        }\n        return false;\n      case TEXT_NODE:\n        if (isExceptionText($(node).textContent, regExceptions))\n          return true;\n        if (debug())\n          logChange(node, parent, property, snippetData);\n        if (aborting)\n          abort(id);\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  // descriptors\n  function getAppendChildDescriptor(target, property, shouldValidate,\n                                    getSnippetData) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let origin = desc.get && call(desc.get, target) || desc.value;\n    if (!origin)\n      return;\n\n    return {\n      get() {\n        return function(...args) {\n          if (shouldValidate(this)) {\n            let snippetData = getSnippetData(this);\n            if (snippetData) {\n              let incomingNode = args[0];\n              if (!checkShouldInsert(incomingNode, this, property, snippetData))\n                return incomingNode;\n            }\n          }\n          return apply(origin, this, args);\n        };\n      }\n    };\n  }\n\n  function getAppendDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let origin = desc.get && call(desc.get, target) || desc.value;\n    if (!origin)\n      return;\n    return {\n      get() {\n        return function(...nodesOrDOMStrings) {\n          if (!shouldValidate(this))\n            return apply(origin, this, nodesOrDOMStrings);\n\n          let snippetData = getSnippetData(this);\n          if (!snippetData)\n            return apply(origin, this, nodesOrDOMStrings);\n\n          let accepted = checkMultiple(\n            nodesOrDOMStrings, this, property, snippetData\n          );\n          if (accepted.length > 0)\n            return apply(origin, this, accepted);\n        };\n      }\n    };\n  }\n\n  function getInsertAdjacentDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let origin = desc.get && call(desc.get, target) || desc.value;\n    if (!origin)\n      return;\n\n    return {\n      get() {\n        return function(...args) {\n          let [position, value] = args;\n          let isInsideTarget =\n              position === \"afterbegin\" || position === \"beforeend\";\n          if (shouldValidate(this, isInsideTarget)) {\n            let snippetData = getSnippetData(this, isInsideTarget);\n            if (snippetData) {\n              let parent = isInsideTarget ?\n                           this :\n                           $(this).parentNode;\n              let finalValue;\n              switch (property) {\n                case \"insertAdjacentElement\":\n                  if (!checkShouldInsert(value, parent, property, snippetData))\n                    return value;\n                  break;\n\n                case \"insertAdjacentHTML\":\n                  finalValue = checkHTML(value, parent, property, snippetData);\n                  if (finalValue)\n                    return call(origin, this, position, finalValue);\n\n\n                  return;\n\n                case \"insertAdjacentText\":\n                  if (!checkShouldInsert(value, parent, property, snippetData))\n                    return;\n                  break;\n\n                default:\n                  break;\n              }\n            }\n          }\n          return apply(origin, this, args);\n        };\n      }\n    };\n  }\n\n  function getInnerHTMLDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let {set: prevSetter} = desc;\n    if (!prevSetter)\n      return;\n\n    return {\n      set(htmlText) {\n        if (!shouldValidate(this))\n          return call(prevSetter, this, htmlText);\n\n        let snippetData = getSnippetData(this);\n        if (!snippetData)\n          return call(prevSetter, this, htmlText);\n        let finalValue = checkHTML(htmlText, this, property, snippetData);\n        if (finalValue)\n          return call(prevSetter, this, finalValue);\n      }\n    };\n  }\n\n  function getTextContentDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let {set: prevSetter} = desc;\n    if (!prevSetter)\n      return;\n\n    return {\n      set(domString) {\n        if (!shouldValidate(this))\n          return call(prevSetter, this, domString);\n\n        let snippetData = getSnippetData(this);\n        if (!snippetData)\n          return call(prevSetter, this, domString);\n        if (checkShouldInsert(domString, this, property, snippetData))\n          return call(prevSetter, this, domString);\n      }\n    };\n  }\n}\n","import $ from \"../$.js\";\nimport {apply, proxy} from \"proxy-pants/function\";\n\nimport {toRegExp} from \"../utils/general.js\";\nimport {hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\nconst {Map, MutationObserver, Object, Set, WeakSet} = $(window);\n\nlet ElementProto = Element.prototype;\nlet {attachShadow} = ElementProto;\n\nlet hiddenShadowRoots = new WeakSet();\nlet searches = new Map();\nlet observer = null;\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element's shadow contains a given string.\n * @alias module:content/snippets.hide-if-shadow-contains\n *\n * @param {string} search The string to look for in every HTML element's\n *   shadow. If the string begins and ends with a slash (`/`), the text in\n *   between is treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n *\n * @since Adblock Plus 3.3\n */\nexport function hideIfShadowContains(search, selector = \"*\") {\n  // Add new searches only if needed, accordingly with the selector.\n  let key = `${search}\\\\${selector}`;\n  if (!searches.has(key)) {\n    searches.set(key, [toRegExp(search), selector, raceWinner(\n      \"hide-if-shadow-contains\",\n      () => {\n        searches.delete(key);\n      })\n    ]);\n  }\n\n  // Bootstrap the observer and the proxied attachShadow wrap once.\n  if (!observer) {\n    observer = new MutationObserver(records => {\n      let visited = new Set();\n      for (let {target} of $(records)) {\n        // retrieve the ShadowRoot\n        let parent = $(target).parentNode;\n        while (parent)\n          [target, parent] = [parent, $(target).parentNode];\n\n        // avoid checking hidden shadow roots\n        if (hiddenShadowRoots.has(target))\n          continue;\n\n        // avoid checking twice the same shadow root node\n        if (visited.has(target))\n          continue;\n\n        visited.add(target);\n\n        for (let [re, selfOrParent, win] of searches.values()) {\n          if (re.test($(target).textContent)) {\n            let closest = $(target.host).closest(selfOrParent);\n            if (closest) {\n              win();\n              // always hide the host of shadow-root\n              $(target).appendChild(\n                document.createElement(\"style\")\n              ).textContent = \":host {display: none !important}\";\n              // hide desired element, which is the host itself\n              // or one of its ancestors\n              hideElement(closest);\n              // mark shadow root as hidden\n              hiddenShadowRoots.add(target);\n            }\n          }\n        }\n      }\n    });\n\n    Object.defineProperty(ElementProto, \"attachShadow\", {\n      // Proxy whatever was set as attachShadow\n      value: proxy(attachShadow, function() {\n        // Create the shadow root first. It doesn't matter if it's a closed\n        // shadow root, we keep the reference in a weak map.\n        let root = apply(attachShadow, this, arguments);\n\n        // Listen for relevant DOM mutations in the shadow.\n        observer.observe(root, {\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n\n        return root;\n      })\n    });\n  }\n}\n","import $ from \"../$.js\";\nimport {apply, proxy} from \"proxy-pants/function\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {findOwner, overrideValue} from \"../utils/execution.js\";\n\nconst {Error, JSON, Map, Object} = $(window);\n\n// will be a Map of all paths, once the snippet is used at least once\nlet paths = null;\n\n/**\n * Traps calls to JSON.parse, and if the result of the parsing is an Object, it\n * will replace specified properties from the result before returning to the\n * caller.\n * @alias module:content/snippets.json-override\n *\n * @param {string} rawOverridePaths A list of space-separated properties\n * to replace.\n * @param {string} value The value to override the properties with.\n * Possible values to override the property with:\n *   undefined\n *   false\n *   true\n *   null\n *   noopFunc    - function with empty body\n *   trueFunc    - function returning true\n *   falseFunc   - function returning false\n *   ''          - empty string\n *   positive decimal integer, no sign, with maximum value of 0x7FFF\n *   emptyArray  - an array with no elements\n *   emptyObject - an object with no properties\n *\n * @param {?string} [rawNeedlePaths] A list of space-separated properties which\n *   must be all present for the pruning to occur.\n * @param {?string} [filter] A string to look for in the raw string,\n * before it's passed to JSON.parse.\n * If no match is found no further search is done on the resulting object.\n * If the string begins and ends with a slash (/),\n * the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.11.2\n */\nexport function jsonOverride(rawOverridePaths, value,\n                             rawNeedlePaths = \"\", filter = \"\") {\n  if (!rawOverridePaths)\n    throw new Error(\"[json-override snippet]: Missing paths to override.\");\n\n  if (typeof value == \"undefined\")\n    throw new Error(\"[json-override snippet]: No value to override with.\");\n\n  if (!paths) {\n    let debugLog = getDebugger(\"json-override\");\n\n    // allow both jsonPrune and jsonOverride to work together\n    let {parse} = JSON;\n    paths = new Map();\n\n    Object.defineProperty(window.JSON, \"parse\", {\n      value: proxy(parse, function(str) {\n        let result = apply(parse, this, arguments);\n\n        for (let {prune, needle, filter: flt, value: val} of paths.values()) {\n          if (flt && !flt.test(str))\n            continue;\n\n          if ($(needle).some(path => !findOwner(result, path)))\n            return result;\n\n          for (let path of prune) {\n            let details = findOwner(result, path);\n            if (typeof details != \"undefined\") {\n              debugLog(`Found ${path} replaced it with ${val}`);\n              details[0][details[1]] = overrideValue(val);\n            }\n          }\n        }\n\n        return result;\n      })\n    });\n    debugLog(\"Wrapped JSON.parse for override\");\n  }\n\n  // allow a single unique rawOverridePaths definition per domain\n  // TBD: should we throw an error if it was already set?\n  paths.set(rawOverridePaths, {\n    prune: $(rawOverridePaths).split(/ +/),\n    needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : [],\n    filter: filter ? toRegExp(filter) : null,\n    value\n  });\n}\n","import $ from \"../$.js\";\nimport {apply, proxy} from \"proxy-pants/function\";\n\nimport {findOwner} from \"../utils/execution.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Error, JSON, Map, Object} = $(window);\n\n// will be a Map of all paths, once the snippet is used at least once\nlet paths = null;\n\n/**\n * Traps calls to JSON.parse, and if the result of the parsing is an Object, it\n * will remove specified properties from the result before returning to the\n * caller.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/gorhill/uBlock/commit/2fd86a66).\n * @alias module:content/snippets.json-prune\n *\n * @param {string} rawPrunePaths A list of space-separated properties to remove.\n * @param {?string} [rawNeedlePaths] A list of space-separated properties which\n *   must be all present for the pruning to occur.\n *\n * @since Adblock Plus 3.9.0\n */\nexport function jsonPrune(rawPrunePaths, rawNeedlePaths = \"\") {\n  if (!rawPrunePaths)\n    throw new Error(\"Missing paths to prune\");\n\n  if (!paths) {\n    let debugLog = getDebugger(\"json-prune\");\n    // allow both jsonPrune and jsonOverride to work together\n    let {parse} = JSON;\n    paths = new Map();\n\n    Object.defineProperty(window.JSON, \"parse\", {\n      value: proxy(parse, function() {\n        let result = apply(parse, this, arguments);\n\n        for (let {prune, needle} of paths.values()) {\n          if ($(needle).some(path => !findOwner(result, path)))\n            return result;\n\n          for (let path of prune) {\n            let details = findOwner(result, path);\n            if (typeof details != \"undefined\") {\n              debugLog(`Found ${path} and deleted`);\n              delete details[0][details[1]];\n            }\n          }\n        }\n\n        return result;\n      })\n    });\n    debugLog(\"Wrapped JSON.parse for prune\");\n  }\n\n  // allow a single unique rawPrunePaths definition per domain\n  // TBD: should we throw an error if it was already set?\n  paths.set(rawPrunePaths, {\n    prune: $(rawPrunePaths).split(/ +/),\n    needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : []\n  });\n}\n","import $ from \"../$.js\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {overrideValue, wrapPropertyAccess} from \"../utils/execution.js\";\n\nlet {Error} = $(window);\n\n/**\n * Overrides a property's value on the window object with a set of\n * available properties.\n *\n * Possible values to override the property with:\n *   undefined\n *   false\n *   true\n *   null\n *   noopFunc   - function with empty body\n *   trueFunc   - function returning true\n *   falseFunc  - function returning false\n *   emptyArray  - an array with no elements\n *   emptyObject - an object with no properties\n *   ''         - empty string\n *   positive decimal integer, no sign, with maximum value of 0x7FFF\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L2105).\n * @alias module:content/snippets.override-property-read\n *\n * @param {string} property The name of the property.\n * @param {string} value The value to override the property with.\n *\n * @since Adblock Plus 3.9.4\n */\nexport function overridePropertyRead(property, value) {\n  if (!property) {\n    throw new Error(\"[override-property-read snippet]: \" +\n                     \"No property to override.\");\n  }\n  if (typeof value === \"undefined\") {\n    throw new Error(\"[override-property-read snippet]: \" +\n                     \"No value to override with.\");\n  }\n\n  let debugLog = getDebugger(\"override-property-read\");\n\n  let cValue = overrideValue(value);\n\n  let newGetter = () => {\n    debugLog(`${property} override done.`);\n    return cValue;\n  };\n\n  debugLog(`Overriding ${property}.`);\n\n  wrapPropertyAccess(window, property, {get: newGetter, set() {}});\n}\n","import $ from \"../$.js\";\nimport {apply, call, proxy} from \"proxy-pants/function\";\n\nimport {debug} from \"../introspection/debug.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Error, Map, Object, console} = $(window);\n\nlet {toString} = Function.prototype;\nlet EventTargetProto = EventTarget.prototype;\nlet {addEventListener} = EventTargetProto;\n\n// will be a Map of all events, once the snippet is used at least once\nlet events = null;\n\n/**\n * Prevents adding event listeners.\n * @alias module:content/snippets.prevent-listener\n *\n * @param {string} event Pattern that matches the type(s) of event\n * we want to prevent. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {?string} eventHandler Pattern that matches the event handler's\n * declaration. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {?string} selector The CSS selector that the event target must match.\n * If the event target is not an HTML element the event handler is added.\n * @since Adblock Plus 3.11.2\n */\nexport function preventListener(event, eventHandler, selector) {\n  if (!event)\n    throw new Error(\"[prevent-listener snippet]: No event type.\");\n\n  if (!events) {\n    events = new Map();\n\n    let debugLog = getDebugger(\"[prevent]\");\n\n    Object.defineProperty(EventTargetProto, \"addEventListener\", {\n      value: proxy(addEventListener, function(type, listener) {\n        for (let {evt, handlers, selectors} of events.values()) {\n          // bail out ASAP if current type doesn't match\n          if (!evt.test(type))\n            continue;\n\n          let isElement = this instanceof Element;\n\n          // check every possible handler and selector per same event type\n          for (let i = 0; i < handlers.length; i++) {\n            let handler = handlers[i];\n            let sel = selectors[i];\n\n            let handlerMatch = () => handler.test(\n              call(\n                toString,\n                typeof listener === \"function\" ?\n                  listener : listener.handleEvent\n              )\n            );\n\n            if (\n              (handler && !handlerMatch()) ||\n              (sel && !(isElement && $(this).matches(sel)))\n            )\n              continue;\n\n            if (debug()) {\n              console.groupCollapsed(\"DEBUG [prevent] was successful\");\n              debugLog(`type: ${type} matching ${evt}`);\n              debugLog(\"handler:\", listener);\n              if (handler)\n                debugLog(`matching ${handler}`);\n              if (sel)\n                debugLog(\"on element: \", this, ` matching ${sel}`);\n              debugLog(\"was prevented from being added\");\n              console.groupEnd();\n            }\n            return;\n          }\n        }\n        return apply(addEventListener, this, arguments);\n      })\n    });\n\n    debugLog(\"Wrapped addEventListener\");\n  }\n\n  if (!events.has(event))\n    events.set(event, {evt: toRegExp(event), handlers: [], selectors: []});\n\n  let {handlers, selectors} = events.get(event);\n\n  handlers.push(eventHandler ? toRegExp(eventHandler) : null);\n  selectors.push(selector);\n}\n","import $ from \"../$.js\";\nimport {apply, caller, proxy} from \"proxy-pants/function\";\n\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {URL, fetch} = $(window);\n\n// purposely a trap for the native URLSearchParams.prototype\nlet {delete: deleteParam} = caller(URLSearchParams.prototype);\n\nlet parameters;\n\n/**\n * Strips a query string parameter from `fetch()` calls.\n * @alias module:content/snippets.strip-fetch-query-parameter\n *\n * @param {string} name The name of the parameter.\n * @param {?string} [urlPattern] An optional pattern that the URL must match.\n *\n * @since Adblock Plus 3.5.1\n */\nexport function stripFetchQueryParameter(name, urlPattern = null) {\n  // override the `window.fetch` only once\n  if (!parameters) {\n    parameters = new Map();\n    window.fetch = proxy(fetch, (...args) => {\n      let [source] = args;\n      if (typeof source === \"string\") {\n        let url = new URL(source);\n        for (let [key, reg] of parameters) {\n          if (!reg || reg.test(source)) {\n            deleteParam(url.searchParams, key);\n            args[0] = url.href;\n          }\n        }\n      }\n      return apply(fetch, self, args);\n    });\n  }\n\n  parameters.set(name, urlPattern && toRegExp(urlPattern));\n}\n","import {log} from \"../introspection/log.js\";\nimport {apply} from \"proxy-pants/function\";\n\n/**\n * Similar to `log`, but does the logging in the context of the document rather\n * than the content script.\n *\n * This may be used for testing and debugging, especially to verify that the\n * injection of snippets into the document is working without any errors.\n * @alias module:content/snippets.trace\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */\nexport function trace(...args) {\n  // We could simply use console.log here, but the goal is to demonstrate the\n  // usage of snippet dependencies.\n  apply(log, null, args);\n}\n","export const injectedSnippetsList = [\n  \"abort-current-inline-script\",\n  \"abort-on-iframe-property-read\",\n  \"abort-on-iframe-property-write\",\n  \"abort-on-property-read\",\n  \"abort-on-property-write\",\n  \"cookie-remover\",\n  \"debug\",\n  \"freeze-element\",\n  \"hide-if-shadow-contains\",\n  \"json-override\",\n  \"json-prune\",\n  \"override-property-read\",\n  \"prevent-listener\",\n  \"strip-fetch-query-parameter\",\n  \"trace\"\n];\n","// This file includes all snippets *except* the ML one.\n// It's basically a copy of the isolated.js file, without the ML snippet,\n// and a copy of the injected.js file, without the `snipepts` re-declaration.\n\nimport {simulateEvent} from \"../content/behavioral/simulate-event-poc.js\";\nimport {hideIfContains} from\n  \"../content/conditional-hiding/hide-if-contains.js\";\nimport {hideIfContainsAndMatchesStyle} from\n  \"../content/conditional-hiding/hide-if-contains-and-matches-style.js\";\nimport {hideIfContainsImage} from\n  \"../content/conditional-hiding/hide-if-contains-image.js\";\nimport {hideIfContainsVisibleText} from\n  \"../content/conditional-hiding/hide-if-contains-visible-text.js\";\nimport {hideIfHasAndMatchesStyle} from\n  \"../content/conditional-hiding/hide-if-has-and-matches-style.js\";\nimport {hideIfLabelledBy} from\n  \"../content/conditional-hiding/hide-if-labelled-by.js\";\nimport {hideIfMatchesXPath} from\n  \"../content/conditional-hiding/hide-if-matches-xpath.js\";\nimport {setDebug} from \"../content/introspection/debug.js\";\nimport {log} from \"../content/introspection/log.js\";\nimport {race} from \"../content/introspection/race.js\";\n\nexport const snippets = {\n  log,\n  race,\n  \"debug\": setDebug,\n  \"hide-if-matches-xpath\": hideIfMatchesXPath,\n  \"hide-if-contains\": hideIfContains,\n  \"hide-if-contains-visible-text\": hideIfContainsVisibleText,\n  \"hide-if-contains-and-matches-style\": hideIfContainsAndMatchesStyle,\n  \"hide-if-has-and-matches-style\": hideIfHasAndMatchesStyle,\n  \"hide-if-labelled-by\": hideIfLabelledBy,\n  \"hide-if-contains-image\": hideIfContainsImage,\n  \"simulate-event-poc\": simulateEvent\n};\n\nimport {abortCurrentInlineScript} from\n  \"../content/behavioral/abort-current-inline-script.js\";\nimport {abortOnIframePropertyRead} from\n  \"../content/behavioral/abort-on-iframe-property-read.js\";\nimport {abortOnIframePropertyWrite} from\n  \"../content/behavioral/abort-on-iframe-property-write.js\";\nimport {abortOnPropertyRead} from\n  \"../content/behavioral/abort-on-property-read.js\";\nimport {abortOnPropertyWrite} from\n  \"../content/behavioral/abort-on-property-write.js\";\nimport {cookieRemover} from \"../content/behavioral/cookie-remover.js\";\nimport {setDebug as debug} from \"../content/introspection/debug.js\";\nimport {freezeElement} from \"../content/behavioral/freeze-element.js\";\nimport {hideIfShadowContains} from\n  \"../content/conditional-hiding/hide-if-shadow-contains.js\";\nimport {jsonOverride} from \"../content/behavioral/json-override.js\";\nimport {jsonPrune} from \"../content/behavioral/json-prune.js\";\nimport {overridePropertyRead} from\n  \"../content/behavioral/override-property-read.js\";\nimport {preventListener} from \"../content/behavioral/prevent-listener.js\";\nimport {stripFetchQueryParameter} from\n  \"../content/behavioral/strip-fetch-query-parameter.js\";\nimport {trace} from \"../content/introspection/trace.js\";\n\nimport {injectedSnippetsList} from \"./injectedMeta.js\";\n\n// WARNING: this list is ordered alphabetically and the elements must\n// match the order of the injectedSnippetsList.\nconst injectedSnippetsCallbacks = [\n  abortCurrentInlineScript,\n  abortOnIframePropertyRead,\n  abortOnIframePropertyWrite,\n  abortOnPropertyRead,\n  abortOnPropertyWrite,\n  cookieRemover,\n  debug,\n  freezeElement,\n  hideIfShadowContains,\n  jsonOverride,\n  jsonPrune,\n  overridePropertyRead,\n  preventListener,\n  stripFetchQueryParameter,\n  trace\n];\n\nfor (let i = 0, {length} = injectedSnippetsList; i < length; i++)\n  snippets[injectedSnippetsList[i]] = injectedSnippetsCallbacks[i];\n"],"names":["$","Proxy","apply","a","bind","b","call","c","Function","callerHandler","get","target","name","caller","proxy","source","_","self","args","handler","bound","assign","defineProperties","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getPrototypeOf","Object","hasOwnProperty","species","Symbol","Native","Secure","proto","prototype","constructor","statics","length","value","secure","libEnvironment","environment","globalThis","window","ownKeys","Reflect","worldEnvDefined","isIsolatedWorld","world","isMainWorld","isChrome","chrome","runtime","isOtherThanChrome","browser","isExtensionContext","copyIfExtension","create","defineProperty","invokes","classes","Map","RegExp","Set","WeakMap","WeakSet","augment","method","known","key","includes","descriptor","primitive","Super","Class","toString","valueOf","type","toLowerCase","callback","result","this","arguments","variables","frozen","hidden","iframePropertiesToAbort","read","write","abortedIframes","startsCapitalized","console","document","performance","JSON","Math","Number","String","MouseEvent","map","has","test","set","WeakValue","helpers","ws","wm","wv","any","add","setTimeout","env","cleanup","cleanUpCallback","clear","transformOnce","super","concat","join","reduce","unshift","descriptors","chain","current","chained","Array","isArray","setPrototypeOf","slice","getBrand","nodeType","Node","Attr","CanvasRenderingContext2D","CSSStyleDeclaration","Document","Element","HTMLCanvasElement","HTMLElement","HTMLImageElement","HTMLScriptElement","MutationRecord","ShadowRoot","CSS2Properties","upgrade","hint","brand","Error","transformer","getComputedStyle","MutationObserver","XPathEvaluator","XPathExpression","XPathResult","querySelectorAll","$$","$XPathExpression","evaluate","$XPathEvaluator","createExpression","hideElement","element","notifyElementHidden","style","$style","properties","debugCSSProperties","setProperty","push","getPropertyValue","propertyValue","propertyPriority","getPropertyPriority","observe","attributes","attributeFilter","checkElement","initQueryAndApply","selector","$selector","startsWith","endsWith","xpathQuery","evaluator","expression","flag","ORDERED_NODE_SNAPSHOT_TYPE","cb","snapshotLength","i","snapshotItem","forEach","initQueryAll","queryAndApply","elements","e","from","hideIfMatches","match","searchSelector","won","closest","race","win","childList","characterData","subtree","isVisible","visibility","parent","parentElement","getComputedCSSText","cssText","property","trim","parseInt","simulateEvent","event","delay","delayInMiliseconds","dispatchedNodes","observer","findNodesAndDispatchEvents","node","dispatchEvent","bubbles","cancelable","regexEscape","string","replace","toRegExp","pattern","isCaseSensitive","randomId","floor","random","debugging","debug","setDebug","noop","log","getDebugger","stack","action","winners","participants","raceWinner","lose","debugLog","delete","looser","values","hideIfContains","search","re","mo","textContent","disconnect","hideIfContainsAndMatchesStyle","searchStyle","searchRegExp","styleRegExp","searchStyleRegExp","clearTimeout","fetch","Uint8Array","hideIfContainsImage","fetchContent","then","content","uint8ArrayToHex","fetchContentMap","url","as","uid","details","remove","timer","res","catch","toHex","number","hex","repeat","uint8Array","byte","parseFloat","ELEMENT_NODE","TEXT_NODE","hideIfContainsVisibleText","entries","optionalParameters","attr","markerIndex","indexOf","defaultEntries","attributesMap","isTextVisible","valueAsRegex","color","getPseudoContent","pseudo","strings","getAttribute","index","isContained","childNode","parentNode","boxMargin","child","getBoundingClientRect","stretchedParent","left","right","top","bottom","getVisibleContent","parentOverflowNode","checkClosest","text","childNodes","nodeValue","boxMarginStr","seen","hideIfHasAndMatchesStyle","querySelector","hideIfLabelledBy","sameSelector","matched","fallback","label","split","getElementById","innerText","noopProfile","mark","end","profile","id","rate","hideIfMatchesXPath","query","context","accessor","ReferenceError","onerror","NodeProto","ElementProto","propertyAccessors","wrapPropertyAccess","object","$property","dotIndex","currentDescriptor","configurable","newDescriptor","toBeWrapped","newValue","prop","desc","overrideOnError","magic","prev","message","abortOnRead","loggingPrefix","rid","abort","abortOnWrite","abortOnIframe","abortRead","abortWrite","frame","frames","queryAndProxyIframe","addHooksOnDomAdditions","readProps","size","props","writeProps","endCallback","wrapAccess","getInnerHTMLDescriptor","names","getAppendChildDescriptor","currentValue","prevSetter","val","NativeObject","findOwner","root","path","decimals","overrideValue","Script","abortCurrentInlineScript","api","us","currentScript","pop","prevGetter","src","abortOnIframePropertyRead","abortOnIframePropertyWrite","abortOnPropertyRead","abortOnPropertyWrite","cookie","documentCookies","cookieRemover","location","protocol","pair","getCookieMatches","$hostname","hostname","expires","domain","arr","filter","str","HTMLElementProto","DOMParser","freezeElement","options","exceptions","shouldAbort","exceptionSelectors","isRegex","regexExceptions","targetNodes","queryAll","checkOptions","data","changeId","proxyNativeProperties","searchAndAttach","s","optionsChunks","chunk","isFrozen","getSnippetData","getAppendDescriptor","isFrozenOrHasFrozenParent","getSnippetDataFromNodeOrParent","getInsertAdjacentDescriptor","isFrozenAndInsideTarget","getSnippetDataBasedOnTarget","getTextContentDescriptor","error","isInsideTarget","markNodes","nodes","isChild","mutationsList","mutation","addedNodes","logPrefixed","logChange","nodeOrDOMString","snippetData","targetSelector","chgId","isDOMString","groupCollapsed","groupEnd","isExceptionNode","expSelectors","$element","exception","matches","isExceptionText","regExceptions","checkHTML","htmlText","domparser","body","parseFromString","accepted","checkMultiple","outerHTML","nodesOrDOMStrings","checkShouldInsert","aborting","domString","shouldValidate","origin","incomingNode","position","finalValue","attachShadow","hiddenShadowRoots","searches","hideIfShadowContains","records","visited","selfOrParent","host","appendChild","createElement","paths","jsonOverride","rawOverridePaths","rawNeedlePaths","parse","prune","needle","flt","some","jsonPrune","rawPrunePaths","overridePropertyRead","cValue","newGetter","EventTargetProto","EventTarget","addEventListener","events","preventListener","eventHandler","listener","evt","handlers","selectors","isElement","sel","handlerMatch","handleEvent","URL","deleteParam","URLSearchParams","parameters","stripFetchQueryParameter","urlPattern","reg","searchParams","href","trace","injectedSnippetsList","snippets","injectedSnippetsCallbacks"],"mappings":"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"}