{"version":3,"file":"bundle.isolated.js","sources":["../../node_modules/proxy-pants/esm/proxy.js","../../node_modules/proxy-pants/esm/function.js","../../node_modules/proxy-pants/esm/bound.js","../../node_modules/proxy-pants/esm/object.js","../../node_modules/proxy-pants/esm/secure.js","../../lib/content/environment.js","../../lib/content/utils/env.js","../../node_modules/transform-once/esm/index.js","../../lib/content/utils/transformer.js","../../node_modules/proxy-pants/esm/array.js","../../node_modules/proxy-pants/esm/globals.js","../../node_modules/proxy-pants/esm/chain.js","../../lib/content/$.js","../../lib/content/utils/dom.js","../../lib/content/behavioral/simulate-event-poc.js","../../lib/content/utils/general.js","../../lib/content/introspection/debug.js","../../lib/content/introspection/log.js","../../lib/content/introspection/race.js","../../lib/content/conditional-hiding/hide-if-contains.js","../../lib/content/conditional-hiding/hide-if-contains-and-matches-style.js","../../lib/content/conditional-hiding/hide-if-contains-image.js","../../lib/content/conditional-hiding/hide-if-contains-similar-text.js","../../lib/content/conditional-hiding/hide-if-contains-visible-text.js","../../lib/content/conditional-hiding/hide-if-has-and-matches-style.js","../../lib/content/conditional-hiding/hide-if-labelled-by.js","../../lib/content/introspection/profile.js","../../lib/content/conditional-hiding/hide-if-matches-xpath.js","../../lib/webext/isolated.js"],"sourcesContent":["const $ = Proxy;\nexport {$ as Proxy};\n","import {Proxy} from './proxy.js';\n\nconst {apply: a, bind: b, call: c} = Function;\nexport const apply = c.bind(a);\nexport const bind = c.bind(b);\nexport const call = c.bind(c);\n\nconst applierHandler = {\n  get(target, name) {\n    return bind(a, target[name]);\n  }\n};\nexport const applier = target => new Proxy(target, applierHandler);\n\nconst callerHandler = {\n  get(target, name) {\n    return bind(c, target[name]);\n  }\n};\nexport const caller = target => new Proxy(target, callerHandler);\n\nexport const proxy = (source, target) => new Proxy(source, {\n  apply: (_, self, args) => apply(target, self, args)\n});\n","import {Proxy} from './proxy.js';\nimport {bind} from './function.js';\n\nconst handler = {\n  get(target, name) {\n    return bind(target[name], target);\n  }\n};\nexport const bound = target => new Proxy(target, handler);\n","import {bound} from './bound.js';\nimport {caller} from './function.js';\n\nconst {\n  assign,\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf\n} = bound(Object);\n\nconst {hasOwnProperty} = caller({});\n\nexport {\n  assign,\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  hasOwnProperty\n};\n","import {Proxy} from './proxy.js';\nimport {\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptors,\n} from './object.js';\n\nconst {species} = Symbol;\n\nconst handler = {\n  get(target, name) {\n    const Native = target[name];\n    class Secure extends Native {}\n\n    const proto = getOwnPropertyDescriptors(Native.prototype);\n    delete proto.constructor;\n    freeze(defineProperties(Secure.prototype, proto));\n\n    const statics = getOwnPropertyDescriptors(Native);\n    delete statics.length;\n    delete statics.prototype;\n    statics[species] = {value: Secure};\n    return freeze(defineProperties(Secure, statics));\n  }\n};\n\nexport const secure = target => new Proxy(target, handler);\n","/**\n * @typedef {object} Environment\n * @property {Array.<Array>} debugCSSProperties Highlighting options.\n * CSS properties to be applied to the targeted element.\n * @property {string} world Target injection world. 'ISOLATED' or 'MAIN'.\n */\n\n/**\n * A configuration object passed by integrators.\n * @type {Environment}\n * @private\n */\n// eslint-disable-next-line no-undef\nexport const libEnvironment = typeof environment !== \"undefined\" ? environment :\n                                                                   {};\n","/* global chrome, browser, globalThis */\n\nimport {bound} from \"proxy-pants/bound\";\nimport {secure} from \"proxy-pants/secure\";\nimport {libEnvironment} from \"../environment.js\";\n\nif (typeof globalThis === \"undefined\")\n  window.globalThis = window;\n\nconst {apply, ownKeys} = bound(Reflect);\n\nconst worldEnvDefined = \"world\" in libEnvironment;\nconst isIsolatedWorld = worldEnvDefined && libEnvironment.world === \"ISOLATED\";\nconst isMainWorld = worldEnvDefined && libEnvironment.world === \"MAIN\";\nconst isChrome = typeof chrome === \"object\" && !!chrome.runtime;\nconst isOtherThanChrome = typeof browser === \"object\" && !!browser.runtime;\nconst isExtensionContext = !isMainWorld &&\n  (isIsolatedWorld || isChrome || isOtherThanChrome);\nconst copyIfExtension = value => isExtensionContext ?\n  value :\n  create(value, getOwnPropertyDescriptors(value));\n\nconst {\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors\n} = bound(Object);\n\nconst invokes = bound(globalThis);\nconst classes = isExtensionContext ? globalThis : secure(globalThis);\nconst {Map, RegExp, Set, WeakMap, WeakSet} = classes;\n\nconst augment = (source, target, method = null) => {\n  const known = ownKeys(target);\n  for (const key of ownKeys(source)) {\n    if (known.includes(key))\n      continue;\n\n    const descriptor = getOwnPropertyDescriptor(source, key);\n    if (method && \"value\" in descriptor) {\n      const {value} = descriptor;\n      if (typeof value === \"function\")\n        descriptor.value = method(value);\n    }\n    defineProperty(target, key, descriptor);\n  }\n};\n\nconst primitive = name => {\n  const Super = classes[name];\n  class Class extends Super {}\n  const {toString, valueOf} = Super.prototype;\n  defineProperties(Class.prototype, {\n    toString: {value: toString},\n    valueOf: {value: valueOf}\n  });\n  const type = name.toLowerCase();\n  const method = callback => function() {\n    const result = apply(callback, this, arguments);\n    return typeof result === type ? new Class(result) : result;\n  };\n  augment(Super, Class, method);\n  augment(Super.prototype, Class.prototype, method);\n  return Class;\n};\n\nconst variables = freeze({\n  frozen: new WeakMap(),\n  hidden: new WeakSet(),\n  iframePropertiesToAbort: {\n    read: new Set(),\n    write: new Set()\n  },\n  abortedIframes: new WeakMap()\n});\n\nconst startsCapitalized = new RegExp(\"^[A-Z]\");\n\n// all default classes/namespaces that must be secured upfront when\n// the environment is not executing in an isolated world\nexport default new Proxy(new Map([\n  // custom environment variables\n  [\"chrome\", (\n    isExtensionContext && (\n      (isChrome && chrome) ||\n      (isOtherThanChrome && browser)\n    )\n  ) || void 0],\n  [\"isExtensionContext\", isExtensionContext],\n  [\"variables\", variables],\n  // secured references and classes\n  [\"console\", copyIfExtension(console)],\n  [\"document\", globalThis.document],\n  [\"performance\", copyIfExtension(performance)],\n  [\"JSON\", copyIfExtension(JSON)],\n  [\"Map\", Map],\n  [\"Math\", copyIfExtension(Math)],\n  [\"Number\", isExtensionContext ? Number : primitive(\"Number\")],\n  [\"RegExp\", RegExp],\n  [\"Set\", Set],\n  [\"String\", isExtensionContext ? String : primitive(\"String\")],\n  [\"WeakMap\", WeakMap],\n  [\"WeakSet\", WeakSet],\n  // no need to secure but it surely helps if we trust native references\n  [\"MouseEvent\", MouseEvent]\n]), {\n  get(map, key) {\n    if (map.has(key))\n      return map.get(key);\n\n    let value = globalThis[key];\n    if (typeof value === \"function\")\n      value = (startsCapitalized.test(key) ? classes : invokes)[key];\n\n    map.set(key, value);\n    return value;\n  },\n  has(map, key) {\n    return map.has(key);\n  }\n});\n","/*! (c) Andrea Giammarchi - ISC */\n\n// no-op WeakValue mock as WeakRef support is still too little\n// use https://github.com/WebReflection/weak-value#readme otherwise\nclass WeakValue {\n  has() { return false; }\n  set() {}\n}\n\nconst helpers = {WeakSet, WeakMap, WeakValue};\nconst {apply} = Reflect;\n\nexport default function (callback) {'use strict';\n  const {WeakSet, WeakMap, WeakValue} = (this || helpers);\n  const ws = new WeakSet;\n  const wm = new WeakMap;\n  const wv = new WeakValue;\n  return function (any) {\n    if (ws.has(any))\n      return any;\n\n    if (wm.has(any))\n      return wm.get(any);\n\n    if (wv.has(any))\n      return wv.get(any);\n\n    const value = apply(callback, this, arguments);\n    ws.add(value);\n    if (value !== any)\n      (typeof any === 'object' && any ? wm : wv).set(any, value);\n    return value;\n  };\n};\n","// this is required by $ so it cannot be \"magic\" or circular dependency happens\nimport env from \"./env.js\";\nimport transformOnce from \"transform-once\";\n\nconst {Map, WeakMap, WeakSet, setTimeout} = env;\n\nlet cleanup = true;\nlet cleanUpCallback = map => {\n  map.clear();\n  cleanup = !cleanup;\n};\n\nexport default transformOnce.bind({\n  WeakMap,\n  WeakSet,\n  // this allows multiple $(primitives) and it cleans references later on\n  // basically a WeakRef implementation based on a single, shared, timer\n  WeakValue: class extends Map {\n    set(key, value) {\n      if (cleanup) {\n        cleanup = !cleanup;\n        setTimeout(cleanUpCallback, 0, this);\n      }\n      return super.set(key, value);\n    }\n  }\n});\n","import {caller} from './function.js';\n\nconst {concat, includes, join, reduce, unshift} = caller([]);\nexport {concat, includes, join, reduce, unshift};\n","import {secure} from './secure.js';\n\nconst {Map, WeakMap} = secure(globalThis);\nexport {Map, WeakMap};\n","import {apply, bind, call} from './function.js';\nimport {assign, getOwnPropertyDescriptors, getPrototypeOf} from './object.js';\nimport {unshift} from './array.js';\nimport {Map} from './globals.js';\n\nconst map = new Map;\nconst descriptors = target => {\n  const chain = [];\n  let current = target;\n  while (current) {\n    if (map.has(current))\n      unshift(chain, map.get(current));\n    else {\n      const descriptors = getOwnPropertyDescriptors(current);\n      map.set(current, descriptors);\n      unshift(chain, descriptors);\n    }\n    current = getPrototypeOf(current);\n  }\n  unshift(chain, {});\n  return apply(assign, null, chain);\n};\n\nexport const chain = source => {\n  const target = typeof source === 'function' ? source.prototype : source;\n  const chained = descriptors(target);\n  const handler = {\n    get(target, key) {\n      if (key in chained) {\n        const {value, get} = chained[key];\n        if (get)\n          return call(get, target);\n        if (typeof value === 'function')\n          return bind(value, target);\n      }\n      return target[key];\n    },\n    set(target, key, value) {\n      if (key in chained) {\n        const {set} = chained[key];\n        if (set) {\n          call(set, target, value);\n          return true;\n        }\n      }\n      target[key] = value;\n      return true;\n    }\n  };\n  return target => new Proxy(target, handler);\n};\n","/* global chrome, browser, globalThis */\n\nimport env from \"./utils/env.js\";\nimport transformer from \"./utils/transformer.js\";\nimport {call} from \"proxy-pants/function\";\nimport {chain} from \"proxy-pants/chain\";\n\nconst {\n  isExtensionContext,\n  Array,\n  Number,\n  String,\n  Object\n} = env;\n\nconst {isArray} = Array;\nconst {getOwnPropertyDescriptor, setPrototypeOf} = Object;\n\nconst {toString} = Object.prototype;\nconst {slice} = String.prototype;\nconst getBrand = value => call(slice, call(toString, value), 8, -1);\n\nconst {get: nodeType} = getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n\n// the main difference between secured classes and chained prototypes\n// is that chained values are not something we construct at all, it's\n// something we deal with instead, so that proxies are a better option,\n// or better, are less obtrusive if their proxy don't leak in the wild.\nconst chained = isExtensionContext ? {} : {\n  Attr: chain(Attr),\n  CanvasRenderingContext2D: chain(CanvasRenderingContext2D),\n  CSSStyleDeclaration: chain(CSSStyleDeclaration),\n  Document: chain(Document),\n  Element: chain(Element),\n  HTMLCanvasElement: chain(HTMLCanvasElement),\n  HTMLElement: chain(HTMLElement),\n  HTMLImageElement: chain(HTMLImageElement),\n  HTMLScriptElement: chain(HTMLScriptElement),\n  MutationRecord: chain(MutationRecord),\n  Node: chain(Node),\n  ShadowRoot: chain(ShadowRoot),\n\n  // this is some test env shenanigan\n  get CSS2Properties() {\n    return chained.CSSStyleDeclaration;\n  }\n};\n\nconst upgrade = (value, hint) => {\n  if (hint !== \"Element\" && hint in chained)\n    return chained[hint](value);\n\n  if (isArray(value))\n    return setPrototypeOf(value, Array.prototype);\n\n  const brand = getBrand(value);\n  if (brand in chained)\n    return chained[brand](value);\n\n  if (brand in env)\n    return setPrototypeOf(value, env[brand].prototype);\n\n  if (\"nodeType\" in value) {\n    switch (call(nodeType, value)) {\n      case 1:\n        if (!(hint in chained))\n          throw new Error(\"unknown hint \" + hint);\n        return chained[hint](value);\n      case 2:\n        return chained.Attr(value);\n      case 3:\n        return chained.Node(value);\n      case 9:\n        return chained.Document(value);\n    }\n  }\n\n  throw new Error(\"unknown brand \" + brand);\n};\n\n/* eslint valid-jsdoc: 0 */\n/** @type {<T>(t:T)=>t} Any value that can be upgraded or wrapped */\nexport default isExtensionContext ?\n  value => (value === window || value === globalThis ? env : value) :\n  transformer((value, hint = \"Element\") => {\n    if (value === window || value === globalThis)\n      return env;\n\n    switch (typeof value) {\n      case \"object\":\n        return value && upgrade(value, hint);\n\n      case \"string\":\n        return new String(value);\n\n      case \"number\":\n        return new Number(value);\n\n      default:\n        throw new Error(\"unsupported value\");\n    }\n  });\n","/* global checkElement:readonly */\n\nimport $ from \"../$.js\";\nimport {apply, bind} from \"proxy-pants/function\";\n\nimport {libEnvironment} from \"../environment.js\";\n\nlet {\n  document,\n  getComputedStyle,\n  isExtensionContext,\n  variables,\n  Array,\n  MutationObserver,\n  Object,\n  XPathEvaluator,\n  XPathExpression,\n  XPathResult\n} = $(window);\n\n// ensures that $$ is bound only in environments where document exists\nlet {querySelectorAll} = document;\nexport let $$ = querySelectorAll && bind(querySelectorAll, document);\n\n// make `new XPathExpression()` operations safe\nconst {assign, setPrototypeOf} = Object;\n\nclass $XPathExpression extends XPathExpression {\n  evaluate(...args) {\n    return setPrototypeOf(\n      apply(super.evaluate, this, args),\n      XPathResult.prototype\n    );\n  }\n}\n\nclass $XPathEvaluator extends XPathEvaluator {\n  createExpression(...args) {\n    return setPrototypeOf(\n      apply(super.createExpression, this, args),\n      $XPathExpression.prototype\n    );\n  }\n}\n\n/**\n * Hides an HTML element by setting its `style` attribute to\n * `display: none !important`.\n *\n * @param {HTMLElement} element The HTML element to hide.\n * @private\n */\nexport function hideElement(element) {\n  if (variables.hidden.has(element))\n    return;\n\n  notifyElementHidden(element);\n\n  variables.hidden.add(element);\n\n  let {style} = $(element);\n  let $style = $(style, \"CSSStyleDeclaration\");\n  let properties = $([]);\n  let {debugCSSProperties} = libEnvironment;\n\n  for (let [key, value] of (debugCSSProperties || [[\"display\", \"none\"]])) {\n    $style.setProperty(key, value, \"important\");\n    properties.push([key, $style.getPropertyValue(key)]);\n  }\n\n  // Listen for changes to the style property and if our values are unset\n  // then reset them.\n  new MutationObserver(() => {\n    for (let [key, value] of properties) {\n      let propertyValue = $style.getPropertyValue(key);\n      let propertyPriority = $style.getPropertyPriority(key);\n      if (propertyValue != value || propertyPriority != \"important\")\n        $style.setProperty(key, value, \"important\");\n    }\n  }).observe(element, {attributes: true,\n                       attributeFilter: [\"style\"]});\n}\n\n/**\n * Notifies the current contentScript that a new element has been hidden.\n * This is done by calling the globally available `checkElement` function\n * and passing the element.\n *\n * @param {HTMLElement} element The HTML element that was hidden.\n * @private\n */\nfunction notifyElementHidden(element) {\n  if (isExtensionContext && typeof checkElement === \"function\")\n    checkElement(element);\n}\n\n/**\n * A callback function to be applied to a node.\n * @callback queryAndApplyCallback\n * @param {Node} node\n * @private\n */\n\n/**\n * The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @callback queryAndApply\n * @param {queryAndApplyCallback} cb\n * @private\n */\n\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAndApply} The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @private\n */\nexport function initQueryAndApply(selector) {\n  let $selector = selector;\n  if ($selector.startsWith(\"xpath(\") &&\n      $selector.endsWith(\")\")) {\n    let xpathQuery = $selector.slice(6, -1);\n    let evaluator = new $XPathEvaluator();\n    let expression = evaluator.createExpression(xpathQuery, null);\n    // do not use ORDERED_NODE_ITERATOR_TYPE or the test env will fail\n    let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;\n\n    return cb => {\n      if (!cb)\n        return;\n      let result = expression.evaluate(document, flag, null);\n      let {snapshotLength} = result;\n      for (let i = 0; i < snapshotLength; i++)\n        cb(result.snapshotItem(i));\n    };\n  }\n  return cb => $$(selector).forEach(cb);\n}\n\n/**\n * The query function. Retrieves all the nodes in the DOM matching the\n * provided selector.\n * @callback queryAll\n * @returns {Node[]} An array containing all the nodes in the DOM matching\n * the provided selector.\n * @private\n */\n\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAll} The query function. Retrieves all the nodes in the DOM\n * matching the provided selector.\n * @private\n */\nexport function initQueryAll(selector) {\n  let $selector = selector;\n  if ($selector.startsWith(\"xpath(\") &&\n      $selector.endsWith(\")\")) {\n    let queryAndApply = initQueryAndApply(selector);\n    return () => {\n      let elements = $([]);\n      queryAndApply(e => elements.push(e));\n      return elements;\n    };\n  }\n  return () => Array.from($$(selector));\n}\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * it matches the provided condition.\n *\n * @param {function} match The function that provides the matching condition.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @returns {MutationObserver} Augmented MutationObserver object. It has a new\n *   function mo.race added to it. This can be used by the snippets to\n *   disconnect the MutationObserver with the racing mechanism.\n *   Used like: mo.race(raceWinner(() => {mo.disconnect();}));\n * @private\n */\nexport function hideIfMatches(match, selector, searchSelector) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let won;\n  const callback = () => {\n    for (const element of $$(searchSelector)) {\n      const closest = $(element).closest(selector);\n      if (closest && match(element, closest)) {\n        won();\n        hideElement(closest);\n      }\n    }\n  };\n  return assign(\n    new MutationObserver(callback),\n    {\n      race(win) {\n        won = win;\n        this.observe(document, {childList: true,\n                                characterData: true,\n                                subtree: true});\n        callback();\n      }\n    }\n  );\n}\n\n/**\n * Check if an element is visible\n *\n * @param {Element} element The element to check visibility of.\n * @param {CSSStyleDeclaration} style The computed style of element.\n * @param {?Element} closest The closest parent to reach.\n * @return {bool} Whether the element is visible.\n * @private\n */\nexport function isVisible(element, style, closest) {\n  let $style = $(style, \"CSSStyleDeclaration\");\n  if ($style.getPropertyValue(\"display\") == \"none\")\n    return false;\n\n  let visibility = $style.getPropertyValue(\"visibility\");\n  if (visibility == \"hidden\" || visibility == \"collapse\")\n    return false;\n\n  if (!closest || element == closest)\n    return true;\n\n  let parent = $(element).parentElement;\n  if (!parent)\n    return true;\n\n  return isVisible(parent, getComputedStyle(parent), closest);\n}\n\n/**\n * Returns the value of the `cssText` property of the object returned by\n * `getComputedStyle` for the given element.\n *\n * If the value of the `cssText` property is blank, this function computes the\n * value out of the properties available in the object.\n *\n * @param {Element} element The element for which to get the computed CSS text.\n *\n * @returns {string} The computed CSS text.\n * @private\n */\nexport function getComputedCSSText(element) {\n  let style = getComputedStyle(element);\n  let {cssText} = style;\n\n  if (cssText)\n    return cssText;\n\n  for (let property of style)\n    cssText += `${property}: ${style[property]}; `;\n\n  return $(cssText).trim();\n}\n","import $ from \"../$.js\";\n\nimport {initQueryAndApply} from \"../utils/dom.js\";\n\nlet {\n  parseInt,\n  setTimeout,\n  Error,\n  MouseEvent,\n  MutationObserver,\n  WeakSet\n} = $(window);\n\n/**\n * Simulate a mouse event on the page.\n * @alias module:content/snippets.simulate-event-poc\n *\n * @param {string} event Pattern that matches the type(s) of event\n * we want to prevent. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {string} selector The CSS/Xpath selector that an HTML element must\n * match for the event to be triggered.\n * @param {?string} delay The delay between the moment when the node is inserted\n * and the moment when the event is dispatched.\n *\n * @since Adblock Plus 3.11.2\n */\nexport function simulateEvent(event, selector, delay = \"0\") {\n  if (!event)\n    throw new Error(\"[simulate-event snippet]: No event type provided.\");\n  if (!selector)\n    throw new Error(\"[simulate-event snippet]: No selector provided.\");\n\n  let queryAndApply = initQueryAndApply(selector);\n  let delayInMiliseconds = parseInt(delay, 10);\n  let dispatchedNodes = new WeakSet();\n\n  let observer = new MutationObserver(findNodesAndDispatchEvents);\n  observer.observe(document, {childList: true, subtree: true});\n  findNodesAndDispatchEvents();\n\n  function findNodesAndDispatchEvents() {\n    queryAndApply(node => {\n      if (!dispatchedNodes.has(node)) {\n        dispatchedNodes.add(node);\n        setTimeout(() => {\n          $(node).dispatchEvent(\n            new MouseEvent(event, {bubbles: true, cancelable: true})\n          );\n        }, delayInMiliseconds);\n      }\n    });\n  }\n}\n","import $ from \"../$.js\";\n\nlet {Math, RegExp} = $(window);\n\n/**\n * Escapes regular expression special characters in a string.\n *\n * The returned string may be passed to the `RegExp` constructor to match the\n * original string.\n *\n * @param {string} string The string in which to escape special characters.\n *\n * @returns {string} A new string with the special characters escaped.\n * @private\n */\nfunction regexEscape(string) {\n  return $(string).replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n/**\n * Converts a given pattern to a regular expression.\n *\n * @param {string} pattern The pattern to convert. If the pattern begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression. If the pattern begins with a slash (`/`) and it ends with a\n *   (`/i`), the text in between is treated as case insensitive regular\n *   expression; otherwise the pattern is treated as raw text.\n *\n * @returns {RegExp} A `RegExp` object based on the given pattern.\n * @private\n */\nexport function toRegExp(pattern) {\n  let {length} = pattern;\n\n  // regexp in /.../ slashes must have at least length of 2\n  if (length > 1 && pattern[0] === \"/\") {\n    let isCaseSensitive = pattern[length - 1] === \"/\";\n    // if not case sensitive, ensure it's not the string \"/i\" itself\n    if (isCaseSensitive || (length > 2 && $(pattern).endsWith(\"/i\"))) {\n      let args = [$(pattern).slice(1, isCaseSensitive ? -1 : -2)];\n      if (!isCaseSensitive)\n        args.push(\"i\");\n\n      return new RegExp(...args);\n    }\n  }\n\n  return new RegExp(regexEscape(pattern));\n}\n\n/**\n * Generates a random alphanumeric ID consisting of 6 base-36 digits\n * from the range 100000..zzzzzz (both inclusive).\n *\n * @returns {string} The random ID.\n * @private\n */\nexport function randomId() {\n  // 2176782336 is 36^6 which mean 6 chars [a-z0-9]\n  // 60466176 is 36^5\n  // 2176782336 - 60466176 = 2116316160. This ensure to always have 6\n  // chars even if Math.random() returns its minimum value 0.0\n  //\n  return $(Math.floor(Math.random() * 2116316160 + 60466176)).toString(36);\n}\n","/**\n * Whether debug mode is enabled.\n * @type {boolean}\n * @private\n */\nlet debugging = false;\n\n/**\n * Tells if the debug mode is inactive.\n * @memberOf module:content/snippets.debug\n * @returns {boolean}\n */\nexport function debug() {\n  return debugging;\n}\n\n/**\n * Enables debug mode.\n * @alias module:content/snippets.debug\n *\n * @example\n * example.com#$#debug; log 'Hello, world!'\n *\n * @since Adblock Plus 3.8\n */\nexport function setDebug() {\n  debugging = true;\n}\n","import $ from \"../$.js\";\nimport {bind} from \"proxy-pants/function\";\n\nimport {debug} from \"./debug.js\";\n\nconst {console} = $(window);\n\nexport const noop = () => {};\n\n/**\n * Logs its arguments to the console.\n *\n * This may be used for testing and debugging.\n *\n * @alias module:content/snippets.log\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */\nexport function log(...args) {\n  if (debug())\n    $(args).unshift(\"%c DEBUG\", \"font-weight: bold\");\n\n  console.log(...args);\n}\n\n/**\n * Returns a no-op if debugging mode is off, returns a bound log otherwise.\n * @param {string} name the debugger name (first logged value)\n * @returns {function} either a no-op function or the logger one\n */\nexport function getDebugger(name) {\n  return bind(debug() ? log : noop, null, name);\n}\n","import $ from \"../$.js\";\nimport {noop} from \"./log.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Array, Error, Map, parseInt} = $(window);\n\nlet stack = null;\nlet won = null;\n\n// #$#race start; thing1; thing2; race stop;\n\n/**\n * Delimits a race among filters, to be able to disable competing filters when\n * any of them \"wins the race\". `#$#race start; filter1; filter2; race end;`\n * @param {string} action either `start` or `stop` the race.\n * @param {string} winners the amount of possible race's winners: 1 by default.\n */\nexport function race(action, winners = \"1\") {\n  switch (action) {\n    case \"start\":\n      stack = {\n        winners: parseInt(winners, 10) || 1,\n        participants: new Map()\n      };\n      won = new Array();\n      break;\n    case \"end\":\n    case \"finish\":\n    case \"stop\":\n      stack = null;\n      for (let win of won)\n        win();\n      won = null;\n      break;\n    default:\n      throw new Error(`Invalid action: ${action}`);\n  }\n}\n\n/**\n * Returns a function that, when a race is happening, can mark a winner,\n * by invoking all callbacks passed for every other snippet that lost the race.\n * @param {string} name the snippet name that is racing.\n * @param {function} lose a callback that, once invoked, will stop the snippet.\n * @returns {function} a callback to invoke whenever a match happens.\n */\nexport function raceWinner(name, lose) {\n  // without races, every invoke is a noop\n  if (stack === null)\n    return noop;\n\n  // within races though, trap the current stack and winners because more than\n  // a race could be defined for the same domains / filters\n  let current = stack;\n  let {participants} = current;\n  participants.set(win, lose);\n\n  // return a function that, once invoked, becomes a noop every other time and\n  // also invokes every other functions in the race to stop them as loosers\n  return win;\n\n  function win() {\n    // make the noop case the fastest one for any further invoke\n    if (current.winners < 1)\n      return;\n\n    let debugLog = getDebugger(\"race\");\n    debugLog(`${name} won the race`);\n\n    // in case a snippet wins while the race is still happening, queue them all\n    // so that unknown racing snippets get a chance to be disabled later on.\n    // i.e. race start 2; winner1; looser2; winner3; looser4; race end;\n    if (current === stack) {\n      won.push(win);\n    }\n    else {\n      participants.delete(win);\n      if (--current.winners < 1) {\n        for (let looser of participants.values())\n          looser();\n\n        participants.clear();\n      }\n    }\n  }\n}\n","import $ from \"../$.js\";\n\nimport {hideIfMatches} from \"../utils/dom.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element contains a given string.\n * @alias module:content/snippets.hide-if-contains\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n *\n * @since Adblock Plus 3.3\n */\nexport function hideIfContains(search, selector = \"*\", searchSelector = null) {\n  let re = toRegExp(search);\n\n  const mo = hideIfMatches(element => re.test($(element).textContent),\n                           selector,\n                           searchSelector);\n  mo.race(raceWinner(\n    \"hide-if-contains\",\n    () => {\n      mo.disconnect();\n    }\n  ));\n}\n","import $ from \"../$.js\";\n\nimport {$$, getComputedCSSText, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {MutationObserver} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element contains a given string and, optionally, if\n * the element's computed style contains a given string.\n * @alias module:content/snippets.hide-if-contains-and-matches-style\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {string?} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {string?} [style] The string that the computed style of an HTML\n *   element matching `selector` must contain. If the string begins and ends\n *   with a slash (`/`), the text in between is treated as a regular\n *   expression.\n * @param {string?} [searchStyle] The string that the computed style of an HTML\n *   element matching `searchSelector` must contain. If the string begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression.\n *\n * @since Adblock Plus 3.3.2\n */\nexport function hideIfContainsAndMatchesStyle(\n  search,\n  selector = \"*\",\n  searchSelector = null,\n  style = null,\n  searchStyle = null\n) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let searchRegExp = toRegExp(search);\n\n  let styleRegExp = style ? toRegExp(style) : null;\n  let searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;\n\n  let callback = () => {\n    for (let element of $$(searchSelector)) {\n      if (searchRegExp.test($(element).textContent) &&\n          (!searchStyleRegExp ||\n           searchStyleRegExp.test(getComputedCSSText(element)))) {\n        let closest = $(element).closest(selector);\n        if (closest && (!styleRegExp ||\n                        styleRegExp.test(getComputedCSSText(closest)))) {\n          win();\n          hideElement(closest);\n        }\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-contains-and-matches-style\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, characterData: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nimport {$$, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {\n  clearTimeout,\n  fetch,\n  getComputedStyle,\n  setTimeout,\n  Map,\n  MutationObserver,\n  Uint8Array\n} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the background image of the element matches a given pattern.\n * @alias module:content/snippets.hide-if-contains-image\n *\n * @param {string} search The pattern to look for in the background images of\n *   HTML elements. This must be the hexadecimal representation of the image\n *   data for which to look. If the string begins and ends with a slash (`/`),\n *   the text in between is treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given pattern must match. Defaults to the value of the\n *   `selector` argument.\n *\n * @since Adblock Plus 3.4.2\n */\nexport function hideIfContainsImage(search, selector, searchSelector) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let searchRegExp = toRegExp(search);\n\n  let callback = () => {\n    for (let element of $$(searchSelector)) {\n      let style = getComputedStyle(element);\n      let match = $(style[\"background-image\"]).match(/^url\\(\"(.*)\"\\)$/);\n      if (match) {\n        fetchContent(match[1]).then(content => {\n          if (searchRegExp.test(uint8ArrayToHex(new Uint8Array(content)))) {\n            let closest = $(element).closest(selector);\n            if (closest) {\n              win();\n              hideElement(closest);\n            }\n          }\n        });\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-contains-image\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, subtree: true});\n  callback();\n}\n\n\n/**\n * @typedef {object} FetchContentInfo\n * @property {function} remove\n * @property {Promise} result\n * @property {number} timer\n * @private\n */\n\n/**\n * @type {Map.<string, FetchContentInfo>}\n * @private\n */\nlet fetchContentMap = new Map();\n\n\n/**\n * Returns a potentially already resolved fetch auto cleaning, if not requested\n * again, after a certain amount of milliseconds.\n *\n * The resolved fetch is by default `arrayBuffer` but it can be any other kind\n * through the configuration object.\n *\n * @param {string} url The url to fetch\n * @param {object} [options] Optional configuration options.\n *                            By default is {as: \"arrayBuffer\", cleanup: 60000}\n * @param {string} [options.as] The fetch type: \"arrayBuffer\", \"json\", \"text\"..\n * @param {number} [options.cleanup] The cache auto-cleanup delay in ms: 60000\n *\n * @returns {Promise} The fetched result as Uint8Array|string.\n *\n * @example\n * fetchContent('https://any.url.com').then(arrayBuffer => { ... })\n * @example\n * fetchContent('https://a.com', {as: 'json'}).then(json => { ... })\n * @example\n * fetchContent('https://a.com', {as: 'text'}).then(text => { ... })\n * @private\n */\nfunction fetchContent(url, {as = \"arrayBuffer\", cleanup = 60000} = {}) {\n  // make sure the fetch type is unique as the url fetching text or arrayBuffer\n  // will fetch same url twice but it will resolve it as expected instead of\n  // keeping the fetch potentially hanging forever.\n  let uid = as + \":\" + url;\n  let details = fetchContentMap.get(uid) || {\n    remove: () => fetchContentMap.delete(uid),\n    result: null,\n    timer: 0\n  };\n  clearTimeout(details.timer);\n  details.timer = setTimeout(details.remove, cleanup);\n  if (!details.result) {\n    details.result = fetch(url).then(res => res[as]()).catch(details.remove);\n    fetchContentMap.set(uid, details);\n  }\n  return details.result;\n}\n\n/**\n * Converts a number to its hexadecimal representation.\n *\n * @param {number} number The number to convert.\n * @param {number} [length] The <em>minimum</em> length of the hexadecimal\n *   representation. For example, given the number `1024` and the length `8`,\n *   the function returns the value `\"00000400\"`.\n *\n * @returns {string} The hexadecimal representation of the given number.\n * @private\n */\nfunction toHex(number, length = 2) {\n  let hex = $(number).toString(16);\n\n  if (hex.length < length)\n    hex = $(\"0\").repeat(length - hex.length) + hex;\n\n  return hex;\n}\n\n/**\n * Converts a `Uint8Array` object into its hexadecimal representation.\n *\n * @param {Uint8Array} uint8Array The `Uint8Array` object to convert.\n *\n * @returns {string} The hexadecimal representation of the given `Uint8Array`\n *   object.\n * @private\n */\nfunction uint8ArrayToHex(uint8Array) {\n  return uint8Array.reduce((hex, byte) => hex + toHex(byte), \"\");\n}\n","import $ from \"../$.js\";\n\nimport {$$, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nconst {parseFloat, Math, MutationObserver, WeakSet} = $(window);\nconst {min} = Math;\n\n// https://webreflection.blogspot.com/2009/02/levenshtein-algorithm-revisited-25.html\nconst ld = (a, b) => {\n  const len1 = a.length + 1;\n  const len2 = b.length + 1;\n  const d = [[0]];\n  let i = 0;\n  let I = 0;\n\n  while (++i < len2)\n    d[0][i] = i;\n\n  i = 0;\n  while (++i < len1) {\n    const c = a[I];\n    let j = 0;\n    let J = 0;\n    d[i] = [i];\n    while (++j < len2) {\n      d[i][j] = min(d[I][j] + 1, d[i][J] + 1, d[I][J] + (c != b[J]));\n      ++J;\n    }\n    ++I;\n  }\n  return d[len1 - 1][len2 - 1];\n};\n\n/**\n * Hides any HTML element matching a CSS selector if the text content\n * contains someting similar to the string to search for.\n * @alias module:content/snippets.hide-if-contains-similar-text\n *\n * @param {string} search The string to look for, such as \"Sponsored\" or\n *   similar.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {?number} [ignoreChars] The amount of extra chars to ignore while\n *   looking for the text, allowing possible intermediate chars. If the\n *   `search` string is \"Sponsored\" and `ignoreChars` is 1, elements containing\n *   \"zSponsored\", as example, will be considered a match too.\n * @param {?number} [maxSearches] The amount of searches to perform. By default\n *   the search is performed through the whole length of the found text. Pass\n *   an integer to never perform more than X searches per node. As example,\n *   if the word to look for is usually at the beginning, use 1 or 2 to\n *   improve performance while surfing.\n *\n * @since @eyeo/snippets 0.5.2\n */\nexport function hideIfContainsSimilarText(\n  search, selector,\n  searchSelector = null,\n  ignoreChars = 0,\n  maxSearches = 0\n) {\n  const visitedNodes = new WeakSet();\n  const debugLog = getDebugger(\"hide-if-contains-similar-text\");\n  const $search = $(search);\n  const {length} = $search;\n  const chars = length + parseFloat(ignoreChars) || 0;\n  const find = $([...$search]).sort();\n  const guard = parseFloat(maxSearches) || Infinity;\n\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  debugLog(\"Looking for similar text: \" + $search);\n\n  const callback = () => {\n    for (const element of $$(searchSelector)) {\n      if (visitedNodes.has(element))\n        continue;\n\n      visitedNodes.add(element);\n      const {innerText} = $(element);\n      const loop = min(guard, innerText.length - chars + 1);\n      for (let i = 0; i < loop; i++) {\n        const str = $(innerText).substr(i, chars);\n        const distance = ld(find, $([...str]).sort()) - ignoreChars;\n        if (distance <= 0) {\n          const closest = $(element).closest(selector);\n          debugLog(\"Found similar text: \" + $search, closest);\n          if (closest) {\n            win();\n            hideElement(closest);\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-contains-similar-text\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, characterData: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nimport {hideIfMatches, isVisible} from \"../utils/dom.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {log} from \"../introspection/log.js\";\nimport {debug} from \"../introspection/debug.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\nlet {getComputedStyle, Map, WeakSet, parseFloat} = $(window);\n\nconst {ELEMENT_NODE, TEXT_NODE} = Node;\n\n/**\n * Hides any HTML element matching a CSS selector if the visible text content\n * of the element contains a given string.\n * @alias module:content/snippets.hide-if-contains-visible-text\n *\n * @param {string} search The string to match to the visible text. Is considered\n *   visible text that isn't hidden by CSS properties or other means.\n *   If the string begins and ends with a slash (`/`), the text in between is\n *   treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @param {?Array.<string>} [attributes] The CSS attributes a computed style\n *   map of a node should have in order to consider that node hidden.\n *   Syntax: <key>:<value>, where <value> can be a string or a regex (if it\n *   starts and ends with a `/`).\n *\n * @since Adblock Plus 3.11.4\n */\nexport function hideIfContainsVisibleText(search, selector,\n                                          searchSelector = null,\n                                          ...attributes) {\n  let entries = $([]);\n  const optionalParameters = new Map([\n    [\"-snippet-box-margin\", \"2\"]\n  ]);\n\n  for (let attr of attributes) {\n    attr = $(attr);\n    let markerIndex = attr.indexOf(\":\");\n    if (markerIndex < 0)\n      continue;\n\n    let key = attr.slice(0, markerIndex).trim().toString();\n    let value = attr.slice(markerIndex + 1).trim().toString();\n\n    if (key && value) {\n      if (optionalParameters.has(key))\n        optionalParameters.set(key, value);\n      else\n        entries.push([key, value]);\n    }\n  }\n\n  let defaultEntries = $([\n    [\"opacity\", \"0\"],\n    [\"font-size\", \"0px\"],\n    // if color is transparent...\n    [\"color\", \"rgba(0, 0, 0, 0)\"]\n  ]);\n\n  let attributesMap = new Map(defaultEntries.concat(entries));\n\n  /**\n   * Determines if the text inside the element is visible.\n   *\n   * @param {Element} element The element we are checking.\n   * @param {?CSSStyleDeclaration} style The computed style of element. If\n   *   falsey it will be queried.\n   * @returns {bool} Whether the text is visible.\n   * @private\n   */\n  function isTextVisible(element, style) {\n    if (!style)\n      style = getComputedStyle(element);\n\n    style = $(style);\n\n    for (const [key, value] of attributesMap) {\n      let valueAsRegex = toRegExp(value);\n      if (valueAsRegex.test(style.getPropertyValue(key)))\n        return false;\n    }\n\n    let color = style.getPropertyValue(\"color\");\n    if (style.getPropertyValue(\"background-color\") == color)\n      return false;\n\n    return true;\n  }\n\n  /**\n   * Check if a pseudo element has visible text via `content`.\n   *\n   * @param {Element} element The element to check visibility of.\n   * @param {string} pseudo The `::before` or `::after` pseudo selector.\n   * @return {string} The pseudo content or an empty string.\n   * @private\n   */\n  function getPseudoContent(element, pseudo) {\n    let style = getComputedStyle(element, pseudo);\n    if (!isVisible(element, style) || !isTextVisible(element, style))\n      return \"\";\n\n    let {content} = $(style);\n    if (content && content !== \"none\") {\n      let strings = $([]);\n\n      // remove all strings, in quotes, including escaping chars, putting\n      // instead `\\x01${string-index}` in place, which is not valid CSS,\n      // so that it's safe to parse it back at the end of the operation.\n      content = $(content).trim().replace(\n        /([\"'])(?:(?=(\\\\?))\\2.)*?\\1/g,\n        value => `\\x01${strings.push($(value).slice(1, -1)) - 1}`\n      );\n\n      // replace attr(...) with the attribute value or an empty string,\n      // ignoring units and fallback values, as these do not work, or have,\n      // any meaning in the CSS `content` property value.\n      content = content.replace(\n        /\\s*attr\\(\\s*([^\\s,)]+)[^)]*?\\)\\s*/g,\n        (_, name) => $(element).getAttribute(name) || \"\"\n      );\n\n      // replace back all `\\x01${string-index}` values with their corresponding\n      // strings, so that the outcome is a real, cleaned up, `content` value.\n      return content.replace(\n        /\\x01(\\d+)/g,\n        (_, index) => strings[index]);\n    }\n    return \"\";\n  }\n\n  /**\n   * Checks if child element is 100% included in the parent element.\n   *\n   * @param {Element} childNode\n   * @param {Element} parentNode\n   * @param {Object?} conf\n   * @param {Number?} conf.boxMargin\n   * @returns {boolean}\n   */\n  function isContained(childNode, parentNode, {boxMargin = 2} = {}) {\n    const child = $(childNode).getBoundingClientRect();\n    const parent = $(parentNode).getBoundingClientRect();\n    const stretchedParent = {\n      left: parent.left - boxMargin,\n      right: parent.right + boxMargin,\n      top: parent.top - boxMargin,\n      bottom: parent.bottom + boxMargin\n    };\n    return (\n      (stretchedParent.left <= child.left &&\n         child.left <= stretchedParent.right &&\n        stretchedParent.top <= child.top &&\n         child.top <= stretchedParent.bottom) &&\n      (stretchedParent.top <= child.bottom &&\n         child.bottom <= stretchedParent.bottom &&\n        stretchedParent.left <= child.right &&\n         child.right <= stretchedParent.right)\n    );\n  }\n\n  /**\n   * Returns the visible text content from an element and its descendants.\n   *\n   * @param {Element} element The element whose visible text we want.\n   * @param {Element} closest The closest parent to reach while checking\n   *   for visibility.\n   * @param {?CSSStyleDeclaration} style The computed style of element. If\n   *   falsey it will be queried.\n   * @param {Element} parentOverflowNode The closest parent with overflow hidden\n   * @param {?Object} conf Configuration object\n   * @param {?Number} conf.boxMargin The optional parameter that\n   *   can be used to specify how much to stretch the bounding box of the\n   *   overflow parent in pixels. Used to counter the hiding methods that\n   *   involve pushing decoy elements outside an overflow-y:hidden parent\n   *   to make them invisible. Default is 2 pixels.\n   * @returns {string} The text that is visible.\n   * @private\n   */\n  function getVisibleContent(element,\n                             closest,\n                             style,\n                             parentOverflowNode,\n                             {boxMargin = 2} = {}) {\n    let checkClosest = !style;\n    if (checkClosest)\n      style = getComputedStyle(element);\n\n    if (!isVisible(element, style, checkClosest && closest))\n      return \"\";\n\n    if (!parentOverflowNode &&\n      (\n        $(style).getPropertyValue(\"overflow-x\") === \"hidden\" ||\n        $(style).getPropertyValue(\"overflow-y\") === \"hidden\"\n      )\n    )\n      parentOverflowNode = element;\n\n    let text = getPseudoContent(element, \":before\");\n    for (let node of $(element).childNodes) {\n      switch ($(node).nodeType) {\n        case ELEMENT_NODE:\n          text += getVisibleContent(node,\n                                    element,\n                                    getComputedStyle(node),\n                                    parentOverflowNode,\n                                    {boxMargin});\n          break;\n        case TEXT_NODE:\n          // If there is a parent with overflow:hidden, it is possible to push\n          // elements out of the boundary box of that parent to make them\n          // invisible. This clause checks against that. We fallback to the\n          // current behaviour if no overflow parent.\n          if (parentOverflowNode) {\n            if (isContained(element, parentOverflowNode, {boxMargin}) &&\n              isTextVisible(element, style))\n              text += $(node).nodeValue;\n          }\n          else if (isTextVisible(element, style)) {\n            text += $(node).nodeValue;\n          }\n          break;\n      }\n    }\n    return text + getPseudoContent(element, \":after\");\n  }\n  const boxMarginStr = optionalParameters.get(\"-snippet-box-margin\");\n  const boxMargin = parseFloat(boxMarginStr) || 0;\n\n  let re = toRegExp(search);\n  let seen = new WeakSet();\n\n  const mo = hideIfMatches(\n    (element, closest) => {\n      if (seen.has(element))\n        return false;\n\n      seen.add(element);\n      let text = getVisibleContent(element, closest, null, null, {boxMargin});\n      let result = re.test(text);\n      if (debug() && text.length)\n        log(result, re, text);\n      return result;\n    },\n    selector,\n    searchSelector\n  );\n  mo.race(raceWinner(\n    \"hide-if-contains-visible-text\",\n    () => {\n      mo.disconnect();\n    }\n  ));\n}\n","import $ from \"../$.js\";\n\nimport {$$, getComputedCSSText, hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {MutationObserver} = $(window);\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if a\n * descendant of the element matches a given CSS selector and, optionally, if\n * the element's computed style contains a given string.\n * @alias module:content/snippets.hide-if-has-and-matches-style\n *\n * @param {string} search The CSS selector against which to match the\n *   descendants of HTML elements.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the specified descendants must match. Defaults to the value of\n *   the `selector` argument.\n * @param {?string} [style] The string that the computed style of an HTML\n *   element matching `selector` must contain. If the string begins and ends\n *   with a slash (`/`), the text in between is treated as a regular\n *   expression.\n * @param {?string} [searchStyle] The string that the computed style of an HTML\n *   element matching `searchSelector` must contain. If the string begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression.\n *\n * @since Adblock Plus 3.4.2\n */\nexport function hideIfHasAndMatchesStyle(search, selector = \"*\",\n                                         searchSelector = null, style = null,\n                                         searchStyle = null) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let styleRegExp = style ? toRegExp(style) : null;\n  let searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;\n\n  let callback = () => {\n    for (let element of $$(searchSelector)) {\n      if ($(element).querySelector(search) &&\n          (!searchStyleRegExp ||\n           searchStyleRegExp.test(getComputedCSSText(element)))) {\n        let closest = $(element).closest(selector);\n        if (closest && (!styleRegExp ||\n                        styleRegExp.test(getComputedCSSText(closest)))) {\n          win();\n          hideElement(closest);\n        }\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-has-and-matches-style\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {childList: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nimport {$$, hideElement, isVisible} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {getComputedStyle, MutationObserver, WeakSet} = $(window);\n\n/**\n * Hides any HTML element that uses an `aria-labelledby`, or one of its\n * ancestors, if the related aria element contains the searched text.\n * @alias module:content/snippets.hide-if-labelled-by\n *\n * @param {string} search The string to look for in HTML elements. If the\n *   string begins and ends with a slash (`/`), the text in between is treated\n *   as a regular expression.\n * @param {string} selector The CSS selector of an HTML element that uses as\n *   `aria-labelledby` attribute.\n * @param {?string} [searchSelector] The CSS selector of an ancestor of the\n *   HTML element that uses as `aria-labelledby` attribute. Defaults to the\n *   value of the `selector` argument.\n *\n * @since Adblock Plus 3.9\n */\nexport function hideIfLabelledBy(search, selector, searchSelector = null) {\n  let sameSelector = searchSelector == null;\n\n  let searchRegExp = toRegExp(search);\n\n  let matched = new WeakSet();\n\n  let callback = () => {\n    for (let node of $$(selector)) {\n      let closest = sameSelector ?\n                    node :\n                    $(node).closest(searchSelector);\n      if (!closest || !isVisible(node, getComputedStyle(node), closest))\n        continue;\n\n      let attr = $(node).getAttribute(\"aria-labelledby\");\n      let fallback = () => {\n        if (matched.has(closest))\n          return;\n\n        if (searchRegExp.test(\n          $(node).getAttribute(\"aria-label\") || \"\"\n        )) {\n          win();\n          matched.add(closest);\n          hideElement(closest);\n        }\n      };\n\n      if (attr) {\n        for (let label of $(attr).split(/\\s+/)) {\n          let target = $(document).getElementById(label);\n          if (target) {\n            if (!matched.has(target) && searchRegExp.test(target.innerText)) {\n              win();\n              matched.add(target);\n              hideElement(closest);\n            }\n          }\n          else {\n            fallback();\n          }\n        }\n      }\n      else {\n        fallback();\n      }\n    }\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-labelled-by\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {characterData: true, childList: true, subtree: true});\n  callback();\n}\n","import $ from \"../$.js\";\n\nlet {Math, setInterval, chrome, isExtensionContext, performance} = $(window);\n\n/**\n * Default profile(\"...\") returned object when profile mode is disabled.\n * @type {Profiler}\n * @private\n */\nconst noopProfile = {\n  mark() {},\n  end() {},\n  toString() {\n    return \"{mark(){},end(){}}\";\n  }\n};\n\n/**\n * Whether profile mode is inactive.\n * @type {boolean}\n * @private\n */\nlet inactive = true;\n\n/**\n * Tells if the profile is inactive.\n * @memberOf module:content/snippets.profile\n * @returns {boolean}\n */\nexport function inactiveProfile() {\n  return inactive;\n}\n\n/**\n * Enables profile mode.\n * @alias module:content/snippets.profile\n * @since Adblock Plus 3.9\n *\n * @example\n * example.com#$#profile; log 'Hello, world!'\n */\nexport function setProfile() {\n  inactive = false;\n}\n\n/**\n * @typedef {object} Profiler\n * @property {function} mark Add a `performance.mark(uniqueId)` entry.\n * @property {function} end Measure and clear `uniqueId` related marks. If a\n * `true` value is passed as argument, clear related interval and process all\n * collected samples since the creation of the profiler.\n * @private\n */\n\n/**\n * Create an object with `mark()` and `end()` methods to either keep marking a\n * specific profiled name, or ending it.\n *\n * @example\n * let {mark, end} = profile('console.log');\n * mark();\n * console.log(1, 2, 3);\n * end();\n *\n * @param {string} id the callback name or unique ID to profile.\n * @param {number} [rate] The number of times per minute to process samples.\n * @returns {Profiler} The profiler with `mark()` and `end(clear = false)`\n * methods.\n * @private\n */\nexport function profile(id, rate = 10) {\n  if (inactive || !isExtensionContext)\n    return noopProfile;\n\n  function processSamples() {\n    let samples = $([]);\n\n    for (let {name, duration} of performance.getEntriesByType(\"measure\"))\n      samples.push({name, duration});\n\n    if (samples.length) {\n      performance.clearMeasures();\n\n      chrome.runtime.sendMessage({\n        type: \"ewe:profiler.sample\",\n        category: \"snippets\",\n        samples\n      });\n    }\n  }\n\n  // avoid creation of N intervals when the same id is used\n  // over and over (i.e. within loops or multiple profile calls)\n  if (!profile[id]) {\n    profile[id] = setInterval(processSamples,\n                              Math.round(60000 / Math.min(60, rate)));\n  }\n\n  return {\n    mark() {\n      performance.mark(id);\n    },\n    end(clear = false) {\n      performance.measure(id, id);\n      performance.clearMarks(id);\n      if (clear) {\n        clearInterval(profile[id]);\n        delete profile[id];\n        processSamples();\n      }\n    }\n  };\n}\n","import $ from \"../$.js\";\n\nimport {hideElement, initQueryAndApply} from \"../utils/dom.js\";\nimport {profile} from \"../introspection/profile.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\nlet {MutationObserver} = $(window);\n\nconst {ELEMENT_NODE} = Node;\n\n/**\n * Hide a specific element through a XPath 1.0 query string.\n * See {@tutorial xpath-filters} to know more.\n * @alias module:content/snippets.hide-if-matches-xpath\n *\n * @param {string} query The XPath query that targets the element to hide.\n *\n * @since Adblock Plus 3.9.0\n */\nexport function hideIfMatchesXPath(query) {\n  let {mark, end} = profile(\"hide-if-matches-xpath\");\n\n  let queryAndApply = initQueryAndApply(`xpath(${query})`);\n\n  let callback = () => {\n    mark();\n\n    queryAndApply(node => {\n      win();\n      if ($(node).nodeType === ELEMENT_NODE)\n        hideElement(node);\n      else\n        $(node).textContent = \"\";\n    });\n\n    end();\n  };\n\n  let mo = new MutationObserver(callback);\n  let win = raceWinner(\n    \"hide-if-matches-xpath\",\n    () => mo.disconnect()\n  );\n  mo.observe(document, {characterData: true, childList: true, subtree: true});\n  callback();\n}\n","import {simulateEvent} from \"../content/behavioral/simulate-event-poc.js\";\nimport {hideIfContains} from\n  \"../content/conditional-hiding/hide-if-contains.js\";\nimport {hideIfContainsAndMatchesStyle} from\n  \"../content/conditional-hiding/hide-if-contains-and-matches-style.js\";\nimport {hideIfContainsImage} from\n  \"../content/conditional-hiding/hide-if-contains-image.js\";\nimport {hideIfContainsSimilarText} from\n  \"../content/conditional-hiding/hide-if-contains-similar-text.js\";\nimport {hideIfContainsVisibleText} from\n  \"../content/conditional-hiding/hide-if-contains-visible-text.js\";\nimport {hideIfHasAndMatchesStyle} from\n  \"../content/conditional-hiding/hide-if-has-and-matches-style.js\";\nimport {hideIfLabelledBy} from\n  \"../content/conditional-hiding/hide-if-labelled-by.js\";\nimport {hideIfMatchesXPath} from\n  \"../content/conditional-hiding/hide-if-matches-xpath.js\";\nimport {setDebug} from \"../content/introspection/debug.js\";\nimport {log} from \"../content/introspection/log.js\";\nimport {race} from \"../content/introspection/race.js\";\n\nexport const snippets = {\n  log,\n  race,\n  \"debug\": setDebug,\n  \"hide-if-matches-xpath\": hideIfMatchesXPath,\n  \"hide-if-contains\": hideIfContains,\n  \"hide-if-contains-similar-text\": hideIfContainsSimilarText,\n  \"hide-if-contains-visible-text\": hideIfContainsVisibleText,\n  \"hide-if-contains-and-matches-style\": hideIfContainsAndMatchesStyle,\n  \"hide-if-has-and-matches-style\": hideIfHasAndMatchesStyle,\n  \"hide-if-labelled-by\": hideIfLabelledBy,\n  \"hide-if-contains-image\": hideIfContainsImage,\n  \"simulate-event-poc\": simulateEvent\n};\n"],"names":["$","Proxy","apply","a","bind","b","call","c","Function","callerHandler","get","target","name","caller","handler","bound","assign","defineProperties","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getPrototypeOf","Object","species","Symbol","Native","Secure","proto","prototype","constructor","statics","length","value","secure","libEnvironment","environment","globalThis","window","ownKeys","Reflect","worldEnvDefined","isIsolatedWorld","world","isMainWorld","isChrome","chrome","runtime","isOtherThanChrome","browser","isExtensionContext","copyIfExtension","create","defineProperty","invokes","classes","Map","RegExp","Set","WeakMap","WeakSet","augment","source","method","known","key","includes","descriptor","primitive","Super","Class","toString","valueOf","type","toLowerCase","callback","result","this","arguments","variables","frozen","hidden","iframePropertiesToAbort","read","write","abortedIframes","startsCapitalized","console","document","performance","JSON","Math","Number","String","MouseEvent","map","has","test","set","WeakValue","helpers","ws","wm","wv","any","add","setTimeout","env","cleanup","cleanUpCallback","clear","transformOnce","super","concat","join","reduce","unshift","descriptors","chain","current","chained","Array","isArray","setPrototypeOf","slice","getBrand","nodeType","Node","Attr","CanvasRenderingContext2D","CSSStyleDeclaration","Document","Element","HTMLCanvasElement","HTMLElement","HTMLImageElement","HTMLScriptElement","MutationRecord","ShadowRoot","CSS2Properties","upgrade","hint","brand","Error","transformer","getComputedStyle","MutationObserver","XPathEvaluator","XPathExpression","XPathResult","querySelectorAll","$$","$XPathExpression","evaluate","args","$XPathEvaluator","createExpression","hideElement","element","notifyElementHidden","style","$style","properties","debugCSSProperties","setProperty","push","getPropertyValue","propertyValue","propertyPriority","getPropertyPriority","observe","attributes","attributeFilter","checkElement","initQueryAndApply","selector","$selector","startsWith","endsWith","xpathQuery","evaluator","expression","flag","ORDERED_NODE_SNAPSHOT_TYPE","cb","snapshotLength","i","snapshotItem","forEach","hideIfMatches","match","searchSelector","won","closest","race","win","childList","characterData","subtree","isVisible","visibility","parent","parentElement","getComputedCSSText","cssText","property","trim","parseInt","simulateEvent","event","delay","queryAndApply","delayInMiliseconds","dispatchedNodes","observer","findNodesAndDispatchEvents","node","dispatchEvent","bubbles","cancelable","regexEscape","string","replace","toRegExp","pattern","isCaseSensitive","debugging","debug","setDebug","noop","log","getDebugger","stack","action","winners","participants","raceWinner","lose","debugLog","delete","looser","values","hideIfContains","search","re","mo","textContent","disconnect","hideIfContainsAndMatchesStyle","searchStyle","searchRegExp","styleRegExp","searchStyleRegExp","clearTimeout","fetch","Uint8Array","hideIfContainsImage","fetchContent","then","content","uint8ArrayToHex","fetchContentMap","url","as","uid","details","remove","timer","res","catch","toHex","number","hex","repeat","uint8Array","byte","parseFloat","min","ld","len1","len2","d","I","j","J","hideIfContainsSimilarText","ignoreChars","maxSearches","visitedNodes","$search","chars","find","sort","guard","Infinity","innerText","loop","str","substr","distance","ELEMENT_NODE","TEXT_NODE","hideIfContainsVisibleText","entries","optionalParameters","attr","markerIndex","indexOf","defaultEntries","attributesMap","isTextVisible","valueAsRegex","color","getPseudoContent","pseudo","strings","_","getAttribute","index","isContained","childNode","parentNode","boxMargin","child","getBoundingClientRect","stretchedParent","left","right","top","bottom","getVisibleContent","parentOverflowNode","checkClosest","text","childNodes","nodeValue","boxMarginStr","seen","hideIfHasAndMatchesStyle","querySelector","hideIfLabelledBy","sameSelector","matched","fallback","label","split","getElementById","noopProfile","mark","end","profile","id","rate","hideIfMatchesXPath","query","snippets"],"mappings":"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"}