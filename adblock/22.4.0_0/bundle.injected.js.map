{"version":3,"file":"bundle.injected.js","sources":["../../node_modules/proxy-pants/esm/proxy.js","../../node_modules/proxy-pants/esm/function.js","../../node_modules/proxy-pants/esm/bound.js","../../node_modules/proxy-pants/esm/object.js","../../node_modules/proxy-pants/esm/secure.js","../../lib/content/environment.js","../../lib/content/utils/env.js","../../node_modules/transform-once/esm/index.js","../../lib/content/utils/transformer.js","../../node_modules/proxy-pants/esm/array.js","../../node_modules/proxy-pants/esm/globals.js","../../node_modules/proxy-pants/esm/chain.js","../../lib/content/$.js","../../node_modules/proxy-pants/esm/accessor.js","../../lib/content/introspection/debug.js","../../lib/content/introspection/log.js","../../lib/content/utils/general.js","../../lib/content/utils/execution.js","../../lib/content/behavioral/abort-current-inline-script.js","../../lib/content/behavioral/abort-on-iframe-property-read.js","../../lib/content/behavioral/abort-on-iframe-property-write.js","../../lib/content/behavioral/abort-on-property-read.js","../../lib/content/behavioral/abort-on-property-write.js","../../lib/content/behavioral/cookie-remover.js","../../lib/content/utils/dom.js","../../lib/content/behavioral/freeze-element.js","../../lib/content/introspection/race.js","../../lib/content/conditional-hiding/hide-if-shadow-contains.js","../../lib/content/behavioral/json-override.js","../../lib/content/behavioral/json-prune.js","../../lib/content/behavioral/override-property-read.js","../../lib/content/behavioral/prevent-listener.js","../../lib/content/behavioral/strip-fetch-query-parameter.js","../../lib/content/introspection/trace.js","../../lib/webext/injectedMeta.js","../../lib/webext/injected.js"],"sourcesContent":["const $ = Proxy;\nexport {$ as Proxy};\n","import {Proxy} from './proxy.js';\n\nconst {apply: a, bind: b, call: c} = Function;\nexport const apply = c.bind(a);\nexport const bind = c.bind(b);\nexport const call = c.bind(c);\n\nconst applierHandler = {\n  get(target, name) {\n    return bind(a, target[name]);\n  }\n};\nexport const applier = target => new Proxy(target, applierHandler);\n\nconst callerHandler = {\n  get(target, name) {\n    return bind(c, target[name]);\n  }\n};\nexport const caller = target => new Proxy(target, callerHandler);\n\nexport const proxy = (source, target) => new Proxy(source, {\n  apply: (_, self, args) => apply(target, self, args)\n});\n","import {Proxy} from './proxy.js';\nimport {bind} from './function.js';\n\nconst handler = {\n  get(target, name) {\n    return bind(target[name], target);\n  }\n};\nexport const bound = target => new Proxy(target, handler);\n","import {bound} from './bound.js';\nimport {caller} from './function.js';\n\nconst {\n  assign,\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf\n} = bound(Object);\n\nconst {hasOwnProperty} = caller({});\n\nexport {\n  assign,\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  hasOwnProperty\n};\n","import {Proxy} from './proxy.js';\nimport {\n  defineProperties,\n  freeze,\n  getOwnPropertyDescriptors,\n} from './object.js';\n\nconst {species} = Symbol;\n\nconst handler = {\n  get(target, name) {\n    const Native = target[name];\n    class Secure extends Native {}\n\n    const proto = getOwnPropertyDescriptors(Native.prototype);\n    delete proto.constructor;\n    freeze(defineProperties(Secure.prototype, proto));\n\n    const statics = getOwnPropertyDescriptors(Native);\n    delete statics.length;\n    delete statics.prototype;\n    statics[species] = {value: Secure};\n    return freeze(defineProperties(Secure, statics));\n  }\n};\n\nexport const secure = target => new Proxy(target, handler);\n","/**\n * @typedef {object} Environment\n * @property {Array.<Array>} debugCSSProperties Highlighting options.\n * CSS properties to be applied to the targeted element.\n * @property {string} world Target injection world. 'ISOLATED' or 'MAIN'.\n */\n\n/**\n * A configuration object passed by integrators.\n * @type {Environment}\n * @private\n */\n// eslint-disable-next-line no-undef\nexport const libEnvironment = typeof environment !== \"undefined\" ? environment :\n                                                                   {};\n","/* global chrome, browser, globalThis */\n\nimport {bound} from \"proxy-pants/bound\";\nimport {secure} from \"proxy-pants/secure\";\nimport {libEnvironment} from \"../environment.js\";\n\nif (typeof globalThis === \"undefined\")\n  window.globalThis = window;\n\nconst {apply, ownKeys} = bound(Reflect);\n\nconst worldEnvDefined = \"world\" in libEnvironment;\nconst isIsolatedWorld = worldEnvDefined && libEnvironment.world === \"ISOLATED\";\nconst isMainWorld = worldEnvDefined && libEnvironment.world === \"MAIN\";\nconst isChrome = typeof chrome === \"object\" && !!chrome.runtime;\nconst isOtherThanChrome = typeof browser === \"object\" && !!browser.runtime;\nconst isExtensionContext = !isMainWorld &&\n  (isIsolatedWorld || isChrome || isOtherThanChrome);\nconst copyIfExtension = value => isExtensionContext ?\n  value :\n  create(value, getOwnPropertyDescriptors(value));\n\nconst {\n  create,\n  defineProperties,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors\n} = bound(Object);\n\nconst invokes = bound(globalThis);\nconst classes = isExtensionContext ? globalThis : secure(globalThis);\nconst {Map, RegExp, Set, WeakMap, WeakSet} = classes;\n\nconst augment = (source, target, method = null) => {\n  const known = ownKeys(target);\n  for (const key of ownKeys(source)) {\n    if (known.includes(key))\n      continue;\n\n    const descriptor = getOwnPropertyDescriptor(source, key);\n    if (method && \"value\" in descriptor) {\n      const {value} = descriptor;\n      if (typeof value === \"function\")\n        descriptor.value = method(value);\n    }\n    defineProperty(target, key, descriptor);\n  }\n};\n\nconst primitive = name => {\n  const Super = classes[name];\n  class Class extends Super {}\n  const {toString, valueOf} = Super.prototype;\n  defineProperties(Class.prototype, {\n    toString: {value: toString},\n    valueOf: {value: valueOf}\n  });\n  const type = name.toLowerCase();\n  const method = callback => function() {\n    const result = apply(callback, this, arguments);\n    return typeof result === type ? new Class(result) : result;\n  };\n  augment(Super, Class, method);\n  augment(Super.prototype, Class.prototype, method);\n  return Class;\n};\n\nconst variables = freeze({\n  frozen: new WeakMap(),\n  hidden: new WeakSet(),\n  iframePropertiesToAbort: {\n    read: new Set(),\n    write: new Set()\n  },\n  abortedIframes: new WeakMap()\n});\n\nconst startsCapitalized = new RegExp(\"^[A-Z]\");\n\n// all default classes/namespaces that must be secured upfront when\n// the environment is not executing in an isolated world\nexport default new Proxy(new Map([\n  // custom environment variables\n  [\"chrome\", (\n    isExtensionContext && (\n      (isChrome && chrome) ||\n      (isOtherThanChrome && browser)\n    )\n  ) || void 0],\n  [\"isExtensionContext\", isExtensionContext],\n  [\"variables\", variables],\n  // secured references and classes\n  [\"console\", copyIfExtension(console)],\n  [\"document\", globalThis.document],\n  [\"performance\", copyIfExtension(performance)],\n  [\"JSON\", copyIfExtension(JSON)],\n  [\"Map\", Map],\n  [\"Math\", copyIfExtension(Math)],\n  [\"Number\", isExtensionContext ? Number : primitive(\"Number\")],\n  [\"RegExp\", RegExp],\n  [\"Set\", Set],\n  [\"String\", isExtensionContext ? String : primitive(\"String\")],\n  [\"WeakMap\", WeakMap],\n  [\"WeakSet\", WeakSet],\n  // no need to secure but it surely helps if we trust native references\n  [\"MouseEvent\", MouseEvent]\n]), {\n  get(map, key) {\n    if (map.has(key))\n      return map.get(key);\n\n    let value = globalThis[key];\n    if (typeof value === \"function\")\n      value = (startsCapitalized.test(key) ? classes : invokes)[key];\n\n    map.set(key, value);\n    return value;\n  },\n  has(map, key) {\n    return map.has(key);\n  }\n});\n","/*! (c) Andrea Giammarchi - ISC */\n\n// no-op WeakValue mock as WeakRef support is still too little\n// use https://github.com/WebReflection/weak-value#readme otherwise\nclass WeakValue {\n  has() { return false; }\n  set() {}\n}\n\nconst helpers = {WeakSet, WeakMap, WeakValue};\nconst {apply} = Reflect;\n\nexport default function (callback) {'use strict';\n  const {WeakSet, WeakMap, WeakValue} = (this || helpers);\n  const ws = new WeakSet;\n  const wm = new WeakMap;\n  const wv = new WeakValue;\n  return function (any) {\n    if (ws.has(any))\n      return any;\n\n    if (wm.has(any))\n      return wm.get(any);\n\n    if (wv.has(any))\n      return wv.get(any);\n\n    const value = apply(callback, this, arguments);\n    ws.add(value);\n    if (value !== any)\n      (typeof any === 'object' && any ? wm : wv).set(any, value);\n    return value;\n  };\n};\n","// this is required by $ so it cannot be \"magic\" or circular dependency happens\nimport env from \"./env.js\";\nimport transformOnce from \"transform-once\";\n\nconst {Map, WeakMap, WeakSet, setTimeout} = env;\n\nlet cleanup = true;\nlet cleanUpCallback = map => {\n  map.clear();\n  cleanup = !cleanup;\n};\n\nexport default transformOnce.bind({\n  WeakMap,\n  WeakSet,\n  // this allows multiple $(primitives) and it cleans references later on\n  // basically a WeakRef implementation based on a single, shared, timer\n  WeakValue: class extends Map {\n    set(key, value) {\n      if (cleanup) {\n        cleanup = !cleanup;\n        setTimeout(cleanUpCallback, 0, this);\n      }\n      return super.set(key, value);\n    }\n  }\n});\n","import {caller} from './function.js';\n\nconst {concat, includes, join, reduce, unshift} = caller([]);\nexport {concat, includes, join, reduce, unshift};\n","import {secure} from './secure.js';\n\nconst {Map, WeakMap} = secure(globalThis);\nexport {Map, WeakMap};\n","import {apply, bind, call} from './function.js';\nimport {assign, getOwnPropertyDescriptors, getPrototypeOf} from './object.js';\nimport {unshift} from './array.js';\nimport {Map} from './globals.js';\n\nconst map = new Map;\nconst descriptors = target => {\n  const chain = [];\n  let current = target;\n  while (current) {\n    if (map.has(current))\n      unshift(chain, map.get(current));\n    else {\n      const descriptors = getOwnPropertyDescriptors(current);\n      map.set(current, descriptors);\n      unshift(chain, descriptors);\n    }\n    current = getPrototypeOf(current);\n  }\n  unshift(chain, {});\n  return apply(assign, null, chain);\n};\n\nexport const chain = source => {\n  const target = typeof source === 'function' ? source.prototype : source;\n  const chained = descriptors(target);\n  const handler = {\n    get(target, key) {\n      if (key in chained) {\n        const {value, get} = chained[key];\n        if (get)\n          return call(get, target);\n        if (typeof value === 'function')\n          return bind(value, target);\n      }\n      return target[key];\n    },\n    set(target, key, value) {\n      if (key in chained) {\n        const {set} = chained[key];\n        if (set) {\n          call(set, target, value);\n          return true;\n        }\n      }\n      target[key] = value;\n      return true;\n    }\n  };\n  return target => new Proxy(target, handler);\n};\n","/* global chrome, browser, globalThis */\n\nimport env from \"./utils/env.js\";\nimport transformer from \"./utils/transformer.js\";\nimport {call} from \"proxy-pants/function\";\nimport {chain} from \"proxy-pants/chain\";\n\nconst {\n  isExtensionContext,\n  Array,\n  Number,\n  String,\n  Object\n} = env;\n\nconst {isArray} = Array;\nconst {getOwnPropertyDescriptor, setPrototypeOf} = Object;\n\nconst {toString} = Object.prototype;\nconst {slice} = String.prototype;\nconst getBrand = value => call(slice, call(toString, value), 8, -1);\n\nconst {get: nodeType} = getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n\n// the main difference between secured classes and chained prototypes\n// is that chained values are not something we construct at all, it's\n// something we deal with instead, so that proxies are a better option,\n// or better, are less obtrusive if their proxy don't leak in the wild.\nconst chained = isExtensionContext ? {} : {\n  Attr: chain(Attr),\n  CanvasRenderingContext2D: chain(CanvasRenderingContext2D),\n  CSSStyleDeclaration: chain(CSSStyleDeclaration),\n  Document: chain(Document),\n  Element: chain(Element),\n  HTMLCanvasElement: chain(HTMLCanvasElement),\n  HTMLElement: chain(HTMLElement),\n  HTMLImageElement: chain(HTMLImageElement),\n  HTMLScriptElement: chain(HTMLScriptElement),\n  MutationRecord: chain(MutationRecord),\n  Node: chain(Node),\n  ShadowRoot: chain(ShadowRoot),\n\n  // this is some test env shenanigan\n  get CSS2Properties() {\n    return chained.CSSStyleDeclaration;\n  }\n};\n\nconst upgrade = (value, hint) => {\n  if (hint !== \"Element\" && hint in chained)\n    return chained[hint](value);\n\n  if (isArray(value))\n    return setPrototypeOf(value, Array.prototype);\n\n  const brand = getBrand(value);\n  if (brand in chained)\n    return chained[brand](value);\n\n  if (brand in env)\n    return setPrototypeOf(value, env[brand].prototype);\n\n  if (\"nodeType\" in value) {\n    switch (call(nodeType, value)) {\n      case 1:\n        if (!(hint in chained))\n          throw new Error(\"unknown hint \" + hint);\n        return chained[hint](value);\n      case 2:\n        return chained.Attr(value);\n      case 3:\n        return chained.Node(value);\n      case 9:\n        return chained.Document(value);\n    }\n  }\n\n  throw new Error(\"unknown brand \" + brand);\n};\n\n/* eslint valid-jsdoc: 0 */\n/** @type {<T>(t:T)=>t} Any value that can be upgraded or wrapped */\nexport default isExtensionContext ?\n  value => (value === window || value === globalThis ? env : value) :\n  transformer((value, hint = \"Element\") => {\n    if (value === window || value === globalThis)\n      return env;\n\n    switch (typeof value) {\n      case \"object\":\n        return value && upgrade(value, hint);\n\n      case \"string\":\n        return new String(value);\n\n      case \"number\":\n        return new Number(value);\n\n      default:\n        throw new Error(\"unsupported value\");\n    }\n  });\n","import {Proxy} from './proxy.js';\nimport {apply, call} from './function.js';\nimport {\n  getOwnPropertyDescriptor,\n  getPrototypeOf,\n  hasOwnProperty\n} from './object.js';\n\nconst handler = {\n  get(target, name) {\n    const context = target;\n    while (!hasOwnProperty(target, name))\n      target = getPrototypeOf(target);\n    const {get, set} = getOwnPropertyDescriptor(target, name);\n    return function () {\n      return arguments.length ?\n              apply(set, context, arguments) :\n              call(get, context);\n    };\n  }\n};\n\nexport const accessor = target => new Proxy(target, handler);\n","/**\n * Whether debug mode is enabled.\n * @type {boolean}\n * @private\n */\nlet debugging = false;\n\n/**\n * Tells if the debug mode is inactive.\n * @memberOf module:content/snippets.debug\n * @returns {boolean}\n */\nexport function debug() {\n  return debugging;\n}\n\n/**\n * Enables debug mode.\n * @alias module:content/snippets.debug\n *\n * @example\n * example.com#$#debug; log 'Hello, world!'\n *\n * @since Adblock Plus 3.8\n */\nexport function setDebug() {\n  debugging = true;\n}\n","import $ from \"../$.js\";\nimport {bind} from \"proxy-pants/function\";\n\nimport {debug} from \"./debug.js\";\n\nconst {console} = $(window);\n\nexport const noop = () => {};\n\n/**\n * Logs its arguments to the console.\n *\n * This may be used for testing and debugging.\n *\n * @alias module:content/snippets.log\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */\nexport function log(...args) {\n  if (debug())\n    $(args).unshift(\"%c DEBUG\", \"font-weight: bold\");\n\n  console.log(...args);\n}\n\n/**\n * Returns a no-op if debugging mode is off, returns a bound log otherwise.\n * @param {string} name the debugger name (first logged value)\n * @returns {function} either a no-op function or the logger one\n */\nexport function getDebugger(name) {\n  return bind(debug() ? log : noop, null, name);\n}\n","import $ from \"../$.js\";\n\nlet {Math, RegExp} = $(window);\n\n/**\n * Escapes regular expression special characters in a string.\n *\n * The returned string may be passed to the `RegExp` constructor to match the\n * original string.\n *\n * @param {string} string The string in which to escape special characters.\n *\n * @returns {string} A new string with the special characters escaped.\n * @private\n */\nfunction regexEscape(string) {\n  return $(string).replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\n\n/**\n * Converts a given pattern to a regular expression.\n *\n * @param {string} pattern The pattern to convert. If the pattern begins and\n *   ends with a slash (`/`), the text in between is treated as a regular\n *   expression. If the pattern begins with a slash (`/`) and it ends with a\n *   (`/i`), the text in between is treated as case insensitive regular\n *   expression; otherwise the pattern is treated as raw text.\n *\n * @returns {RegExp} A `RegExp` object based on the given pattern.\n * @private\n */\nexport function toRegExp(pattern) {\n  let {length} = pattern;\n\n  // regexp in /.../ slashes must have at least length of 2\n  if (length > 1 && pattern[0] === \"/\") {\n    let isCaseSensitive = pattern[length - 1] === \"/\";\n    // if not case sensitive, ensure it's not the string \"/i\" itself\n    if (isCaseSensitive || (length > 2 && $(pattern).endsWith(\"/i\"))) {\n      let args = [$(pattern).slice(1, isCaseSensitive ? -1 : -2)];\n      if (!isCaseSensitive)\n        args.push(\"i\");\n\n      return new RegExp(...args);\n    }\n  }\n\n  return new RegExp(regexEscape(pattern));\n}\n\n/**\n * Generates a random alphanumeric ID consisting of 6 base-36 digits\n * from the range 100000..zzzzzz (both inclusive).\n *\n * @returns {string} The random ID.\n * @private\n */\nexport function randomId() {\n  // 2176782336 is 36^6 which mean 6 chars [a-z0-9]\n  // 60466176 is 36^5\n  // 2176782336 - 60466176 = 2116316160. This ensure to always have 6\n  // chars even if Math.random() returns its minimum value 0.0\n  //\n  return $(Math.floor(Math.random() * 2116316160 + 60466176)).toString(36);\n}\n","import $ from \"../$.js\";\nimport {accessor} from \"proxy-pants/accessor\";\nimport {apply, call} from \"proxy-pants/function\";\nimport {hasOwnProperty} from \"proxy-pants/object\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {randomId} from \"./general.js\";\n\nlet {\n  parseFloat,\n  variables,\n  Array,\n  Error,\n  Map,\n  Object,\n  ReferenceError,\n  Set,\n  WeakMap\n} = $(window);\n\nlet {onerror} = accessor(window);\n\nlet NodeProto = Node.prototype;\nlet ElementProto = Element.prototype;\n\nlet propertyAccessors = null;\n\nexport function wrapPropertyAccess(object, property, descriptor) {\n  let $property = $(property);\n  let dotIndex = $property.indexOf(\".\");\n  if (dotIndex == -1) {\n    // simple property case.\n    let currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n    if (currentDescriptor && !currentDescriptor.configurable)\n      return;\n\n    // Keep it configurable because the same property can be wrapped via\n    // multiple snippet filters (#7373).\n    let newDescriptor = Object.assign({}, descriptor, {\n      configurable: true\n    });\n\n    if (!currentDescriptor && !newDescriptor.get && newDescriptor.set) {\n      let propertyValue = object[property];\n      newDescriptor.get = () => propertyValue;\n    }\n\n    Object.defineProperty(object, property, newDescriptor);\n    return;\n  }\n\n  let name = $property.slice(0, dotIndex);\n  property = $property.slice(dotIndex + 1);\n  let value = object[name];\n  if (value && (typeof value == \"object\" || typeof value == \"function\"))\n    wrapPropertyAccess(value, property, descriptor);\n\n  let currentDescriptor = Object.getOwnPropertyDescriptor(object, name);\n  if (currentDescriptor && !currentDescriptor.configurable)\n    return;\n\n  // lazy initialization (reduced heap)\n  if (!propertyAccessors)\n    propertyAccessors = new WeakMap();\n\n  // allow branched properties that might not exist yet\n  if (!propertyAccessors.has(object))\n    propertyAccessors.set(object, new Map());\n\n  // if the name is already known, simply add the descriptor\n  // to the sub-brnach for the property\n  let properties = propertyAccessors.get(object);\n  if (properties.has(name)) {\n    properties.get(name).set(property, descriptor);\n    return;\n  }\n\n  // in every other case just create the branch and set\n  // the accessor only once for the very same name.\n  let toBeWrapped = new Map([[property, descriptor]]);\n  properties.set(name, toBeWrapped);\n  Object.defineProperty(object, name, {\n    get: () => value,\n    set(newValue) {\n      value = newValue;\n      if (value && (typeof value == \"object\" || typeof value == \"function\")) {\n        // loop through all branches to avoid loosing/overwriting previously\n        // set ones\n        for (let [prop, desc] of toBeWrapped)\n          wrapPropertyAccess(value, prop, desc);\n      }\n    },\n    configurable: true\n  });\n}\n\n/**\n * Overrides the `onerror` handler to discard tagged error messages from our\n * property wrapping.\n *\n * @param {string} magic The magic string that tags the error message.\n * @private\n */\nexport function overrideOnError(magic) {\n  let prev = onerror();\n  onerror((...args) => {\n    let message = args.length && args[0];\n    if (typeof message == \"string\" && $(message).includes(magic))\n      return true;\n    if (typeof prev == \"function\")\n      return apply(prev, this, args);\n  });\n}\n\n/**\n * Patches a property on the `context` object to abort execution when the\n * property is read.\n *\n * @param {string} loggingPrefix A string with which we prefix the logs.\n * @param {Window} context The window object whose property we patch.\n * @param {string} property The name of the property.\n * @private\n */\nexport function abortOnRead(loggingPrefix, context, property) {\n  let debugLog = getDebugger(loggingPrefix);\n\n  if (!property) {\n    debugLog(\"no property to abort on read\");\n    return;\n  }\n\n  let rid = randomId();\n\n  function abort() {\n    debugLog(`${property} access aborted`);\n    throw new ReferenceError(rid);\n  }\n\n  debugLog(`aborting on ${property} access`);\n\n  wrapPropertyAccess(context, property, {get: abort, set() {}});\n  overrideOnError(rid);\n}\n\n/**\n * Patches a property on the `context` object to abort execution when the\n * property is written.\n *\n * @param {string} loggingPrefix A string with which we prefix the logs.\n * @param {Window} context The window object whose property we patch.\n * @param {string} property The name of the property.\n * @private\n */\nexport function abortOnWrite(loggingPrefix, context, property) {\n  let debugLog = getDebugger(loggingPrefix);\n\n  if (!property) {\n    debugLog(\"no property to abort on write\");\n    return;\n  }\n\n  let rid = randomId();\n\n  function abort() {\n    debugLog(`setting ${property} aborted`);\n    throw new ReferenceError(rid);\n  }\n\n  debugLog(`aborting when setting ${property}`);\n\n  wrapPropertyAccess(context, property, {set: abort});\n  overrideOnError(rid);\n}\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is read/written.\n *\n * @param {...string} properties The list with the properties.\n * @param {boolean?} [abortRead=false] Should abort on read option.\n * @param {boolean?} [abortWrite=false] Should abort on write option.\n * @private\n */\nexport function abortOnIframe(\n  properties,\n  abortRead = false,\n  abortWrite = false\n) {\n  let abortedIframes = variables.abortedIframes;\n  let iframePropertiesToAbort = variables.iframePropertiesToAbort;\n\n  // add new properties-to-abort to all aborted iframes' WeakMaps\n  for (let frame of Array.from(window.frames)) {\n    if (abortedIframes.has(frame)) {\n      for (let property of properties) {\n        if (abortRead)\n          abortedIframes.get(frame).read.add(property);\n        if (abortWrite)\n          abortedIframes.get(frame).write.add(property);\n      }\n    }\n  }\n\n  // store properties-to-abort\n  for (let property of properties) {\n    if (abortRead)\n      iframePropertiesToAbort.read.add(property);\n    if (abortWrite)\n      iframePropertiesToAbort.write.add(property);\n  }\n\n  queryAndProxyIframe();\n  if (!abortedIframes.has(document)) {\n    abortedIframes.set(document, true);\n    addHooksOnDomAdditions(queryAndProxyIframe);\n  }\n\n  function queryAndProxyIframe() {\n    for (let frame of Array.from(window.frames)) {\n      // add WeakMap entry for every missing frame\n      if (!abortedIframes.has(frame)) {\n        abortedIframes.set(frame, {\n          read: new Set(iframePropertiesToAbort.read),\n          write: new Set(iframePropertiesToAbort.write)\n        });\n      }\n\n      let readProps = abortedIframes.get(frame).read;\n      if (readProps.size > 0) {\n        let props = Array.from(readProps);\n        readProps.clear();\n        for (let property of props)\n          abortOnRead(\"abort-on-iframe-property-read\", frame, property);\n      }\n\n      let writeProps = abortedIframes.get(frame).write;\n      if (writeProps.size > 0) {\n        let props = Array.from(writeProps);\n        writeProps.clear();\n        for (let property of props)\n          abortOnWrite(\"abort-on-iframe-property-write\", frame, property);\n      }\n    }\n  }\n}\n\n/**\n * Patches the native functions which are responsible with adding Nodes to DOM.\n * Adds a hook at right after the addition.\n *\n * @param {function} endCallback The list with the properties.\n * @private\n */\nfunction addHooksOnDomAdditions(endCallback) {\n  let descriptor;\n\n  wrapAccess(NodeProto, [\"appendChild\", \"insertBefore\", \"replaceChild\"]);\n  wrapAccess(ElementProto, [\"append\", \"prepend\", \"replaceWith\", \"after\",\n                            \"before\", \"insertAdjacentElement\",\n                            \"insertAdjacentHTML\"]);\n\n  descriptor = getInnerHTMLDescriptor(ElementProto, \"innerHTML\");\n  wrapPropertyAccess(ElementProto, \"innerHTML\", descriptor);\n\n  descriptor = getInnerHTMLDescriptor(ElementProto, \"outerHTML\");\n  wrapPropertyAccess(ElementProto, \"outerHTML\", descriptor);\n\n  function wrapAccess(prototype, names) {\n    for (let name of names) {\n      let desc = getAppendChildDescriptor(prototype, name);\n      wrapPropertyAccess(prototype, name, desc);\n    }\n  }\n\n  function getAppendChildDescriptor(target, property) {\n    let currentValue = target[property];\n    return {\n      get() {\n        return function(...args) {\n          let result;\n          result = apply(currentValue, this, args);\n          endCallback && endCallback();\n          return result;\n        };\n      }\n    };\n  }\n\n  function getInnerHTMLDescriptor(target, property) {\n    let desc = Object.getOwnPropertyDescriptor(target, property);\n    let {set: prevSetter} = desc || {};\n    return {\n      set(val) {\n        let result;\n        result = call(prevSetter, this, val);\n        endCallback && endCallback();\n        return result;\n      }\n    };\n  }\n}\n\nlet {Object: NativeObject} = window;\nexport function findOwner(root, path) {\n  if (!(root instanceof NativeObject))\n    return;\n\n  let object = root;\n  let chain = $(path).split(\".\");\n\n  if (chain.length === 0)\n    return;\n\n  for (let i = 0; i < chain.length - 1; i++) {\n    let prop = chain[i];\n    // eslint-disable-next-line no-prototype-builtins\n    if (!hasOwnProperty(object, prop))\n      return;\n\n    object = object[prop];\n\n    if (!(object instanceof NativeObject))\n      return;\n  }\n\n  let prop = chain[chain.length - 1];\n  // eslint-disable-next-line no-prototype-builtins\n  if (hasOwnProperty(object, prop))\n    return [object, prop];\n}\n\n// TBD: should this accept floating numbers too?\nconst decimals = $(/^\\d+$/);\n\nexport function overrideValue(value) {\n  switch (value) {\n    case \"false\":\n      return false;\n    case \"true\":\n      return true;\n    case \"null\":\n      return null;\n    case \"noopFunc\":\n      return () => {};\n    case \"trueFunc\":\n      return () => true;\n    case \"falseFunc\":\n      return () => false;\n    case \"emptyArray\":\n      return [];\n    case \"emptyObj\":\n      return {};\n    case \"undefined\":\n      return void 0;\n    case \"\":\n      return value;\n    default:\n      if (decimals.test(value))\n        return parseFloat(value);\n\n      throw new Error(\"[override-property-read snippet]: \" +\n                      `Value \"${value}\" is not valid.`);\n  }\n}\n","import $ from \"../$.js\";\nimport {call} from \"proxy-pants/function\";\n\nimport {overrideOnError, wrapPropertyAccess} from \"../utils/execution.js\";\nimport {randomId, toRegExp} from \"../utils/general.js\";\n\nlet {HTMLScriptElement, Object, ReferenceError} = $(window);\nlet Script = Object.getPrototypeOf(HTMLScriptElement);\n\n/**\n * Aborts the execution of an inline script.\n * @alias module:content/snippets.abort-current-inline-script\n *\n * @param {string} api API function or property name to anchor on.\n * @param {?string} [search] If specified, only scripts containing the given\n *   string are prevented from executing. If the string begins and ends with a\n *   slash (`/`), the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.4.3\n */\nexport function abortCurrentInlineScript(api, search = null) {\n  let re = search ? toRegExp(search) : null;\n\n  let rid = randomId();\n  let us = $(document).currentScript;\n\n  let object = window;\n  let path = $(api).split(\".\");\n  let name = $(path).pop();\n\n  for (let node of $(path)) {\n    object = object[node];\n\n    if (!object || !(typeof object == \"object\" || typeof object == \"function\"))\n      return;\n  }\n\n  let {get: prevGetter, set: prevSetter} =\n    Object.getOwnPropertyDescriptor(object, name) || {};\n\n  let currentValue = object[name];\n\n  let abort = () => {\n    let element = $(document).currentScript;\n    if (element instanceof Script &&\n        $(element, \"HTMLScriptElement\").src == \"\" &&\n        element != us &&\n        (!re || re.test($(element).textContent)))\n      throw new ReferenceError(rid);\n  };\n\n  let descriptor = {\n    get() {\n      abort();\n\n      if (prevGetter)\n        return call(prevGetter, this);\n\n      return currentValue;\n    },\n    set(value) {\n      abort();\n\n      if (prevSetter)\n        call(prevSetter, this, value);\n      else\n        currentValue = value;\n    }\n  };\n\n  wrapPropertyAccess(object, name, descriptor);\n\n  overrideOnError(rid);\n}\n","import {abortOnIframe} from \"../utils/execution.js\";\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is read.\n *\n * No error is printed to the console.\n * @alias module:content/snippets.abort-on-iframe-property-read\n *\n * @param {...string} properties The list with the properties.\n *\n * @since Adblock Plus 3.10.1\n */\nexport function abortOnIframePropertyRead(...properties) {\n  abortOnIframe(properties, true, false);\n}\n","import {abortOnIframe} from \"../utils/execution.js\";\n\n/**\n * Patches a list of properties on the iframes' window object to abort execution\n * when the property is written.\n *\n * No error is printed to the console.\n * @alias module:content/snippets.abort-on-iframe-property-write\n *\n * @param {...string} properties The list with the properties.\n *\n * @since Adblock Plus 3.10.1\n */\nexport function abortOnIframePropertyWrite(...properties) {\n  abortOnIframe(properties, false, true);\n}\n","import {abortOnRead} from \"../utils/execution.js\";\n\n/**\n * Patches a property on the window object to abort execution when the\n * property is read.\n *\n * No error is printed to the console.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L1703).\n * @alias module:content/snippets.abort-on-property-read\n *\n * @param {string} property The name of the property.\n *\n * @since Adblock Plus 3.4.1\n */\nexport function abortOnPropertyRead(property) {\n  abortOnRead(\"abort-on-property-read\", window, property);\n}\n","import {abortOnWrite} from \"../utils/execution.js\";\n\n/**\n * Patches a property on the window object to abort execution when the\n * property is written.\n *\n * No error is printed to the console.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L1671).\n * @alias module:content/snippets.abort-on-property-write\n *\n * @param {string} property The name of the property.\n *\n * @since Adblock Plus 3.4.3\n */\nexport function abortOnPropertyWrite(property) {\n  abortOnWrite(\"abort-on-property-write\", window, property);\n}\n","import $ from \"../$.js\";\nimport {accessor} from \"proxy-pants/accessor\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {Error} = $(window);\nlet {cookie: documentCookies} = accessor(document);\n\n/**\n * Removes a specific cookie by setting it's expiration date in the past.\n * @alias module:content/snippets.cookie-remover\n *\n * @param {string} cookie The name of the cookie that we want removed.\n * If the string begins and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.11.2\n */\nexport function cookieRemover(cookie) {\n  if (!cookie)\n    throw new Error(\"[cookie-remover snippet]: No cookie to remove.\");\n\n  let debugLog = getDebugger(\"cookie-remover\");\n  let re = toRegExp(cookie);\n\n  // In some cases, when the snippet is executed, the protocol is about:blank\n  // thus preventing us from actually removing the cookie.\n  if (!$(/^http|^about/).test(location.protocol)) {\n    debugLog(\"Snippet only works for http or https and about.\");\n    return;\n  }\n\n  debugLog(\"Parsing cookies for matches\");\n\n  for (const pair of $(getCookieMatches())) {\n    let $hostname = $(location.hostname);\n    let name = $(pair).split(\"=\")[0];\n    let expires = \"expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n    let path = \"path=/\";\n    let domain = \"domain=\" + $hostname.slice($hostname.indexOf(\".\") + 1);\n\n    documentCookies(`${$(name).trim()}=;${expires};${path};${domain}`);\n\n    debugLog(`Set expiration date on ${name}`);\n  }\n\n  function getCookieMatches() {\n    const arr = $(documentCookies()).split(\";\");\n    return arr.filter(str => re.test($(str).split(\"=\")[0]));\n  }\n}\n","/* global checkElement:readonly */\n\nimport $ from \"../$.js\";\nimport {apply, bind} from \"proxy-pants/function\";\n\nimport {libEnvironment} from \"../environment.js\";\n\nlet {\n  document,\n  getComputedStyle,\n  isExtensionContext,\n  variables,\n  Array,\n  MutationObserver,\n  Object,\n  XPathEvaluator,\n  XPathExpression,\n  XPathResult\n} = $(window);\n\n// ensures that $$ is bound only in environments where document exists\nlet {querySelectorAll} = document;\nexport let $$ = querySelectorAll && bind(querySelectorAll, document);\n\n// make `new XPathExpression()` operations safe\nconst {assign, setPrototypeOf} = Object;\n\nclass $XPathExpression extends XPathExpression {\n  evaluate(...args) {\n    return setPrototypeOf(\n      apply(super.evaluate, this, args),\n      XPathResult.prototype\n    );\n  }\n}\n\nclass $XPathEvaluator extends XPathEvaluator {\n  createExpression(...args) {\n    return setPrototypeOf(\n      apply(super.createExpression, this, args),\n      $XPathExpression.prototype\n    );\n  }\n}\n\n/**\n * Hides an HTML element by setting its `style` attribute to\n * `display: none !important`.\n *\n * @param {HTMLElement} element The HTML element to hide.\n * @private\n */\nexport function hideElement(element) {\n  if (variables.hidden.has(element))\n    return;\n\n  notifyElementHidden(element);\n\n  variables.hidden.add(element);\n\n  let {style} = $(element);\n  let $style = $(style, \"CSSStyleDeclaration\");\n  let properties = $([]);\n  let {debugCSSProperties} = libEnvironment;\n\n  for (let [key, value] of (debugCSSProperties || [[\"display\", \"none\"]])) {\n    $style.setProperty(key, value, \"important\");\n    properties.push([key, $style.getPropertyValue(key)]);\n  }\n\n  // Listen for changes to the style property and if our values are unset\n  // then reset them.\n  new MutationObserver(() => {\n    for (let [key, value] of properties) {\n      let propertyValue = $style.getPropertyValue(key);\n      let propertyPriority = $style.getPropertyPriority(key);\n      if (propertyValue != value || propertyPriority != \"important\")\n        $style.setProperty(key, value, \"important\");\n    }\n  }).observe(element, {attributes: true,\n                       attributeFilter: [\"style\"]});\n}\n\n/**\n * Notifies the current contentScript that a new element has been hidden.\n * This is done by calling the globally available `checkElement` function\n * and passing the element.\n *\n * @param {HTMLElement} element The HTML element that was hidden.\n * @private\n */\nfunction notifyElementHidden(element) {\n  if (isExtensionContext && typeof checkElement === \"function\")\n    checkElement(element);\n}\n\n/**\n * A callback function to be applied to a node.\n * @callback queryAndApplyCallback\n * @param {Node} node\n * @private\n */\n\n/**\n * The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @callback queryAndApply\n * @param {queryAndApplyCallback} cb\n * @private\n */\n\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAndApply} The query function. Accepts a callback function\n * which will be called for every node resulted from querying the document.\n * @private\n */\nexport function initQueryAndApply(selector) {\n  let $selector = selector;\n  if ($selector.startsWith(\"xpath(\") &&\n      $selector.endsWith(\")\")) {\n    let xpathQuery = $selector.slice(6, -1);\n    let evaluator = new $XPathEvaluator();\n    let expression = evaluator.createExpression(xpathQuery, null);\n    // do not use ORDERED_NODE_ITERATOR_TYPE or the test env will fail\n    let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;\n\n    return cb => {\n      if (!cb)\n        return;\n      let result = expression.evaluate(document, flag, null);\n      let {snapshotLength} = result;\n      for (let i = 0; i < snapshotLength; i++)\n        cb(result.snapshotItem(i));\n    };\n  }\n  return cb => $$(selector).forEach(cb);\n}\n\n/**\n * The query function. Retrieves all the nodes in the DOM matching the\n * provided selector.\n * @callback queryAll\n * @returns {Node[]} An array containing all the nodes in the DOM matching\n * the provided selector.\n * @private\n */\n\n/**\n * Given a CSS or Xpath selector, returns a query function.\n * @param {string} selector A CSS selector or a Xpath selector which must be\n * described with the following syntax: `xpath(the_actual_selector)`\n * @returns {queryAll} The query function. Retrieves all the nodes in the DOM\n * matching the provided selector.\n * @private\n */\nexport function initQueryAll(selector) {\n  let $selector = selector;\n  if ($selector.startsWith(\"xpath(\") &&\n      $selector.endsWith(\")\")) {\n    let queryAndApply = initQueryAndApply(selector);\n    return () => {\n      let elements = $([]);\n      queryAndApply(e => elements.push(e));\n      return elements;\n    };\n  }\n  return () => Array.from($$(selector));\n}\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * it matches the provided condition.\n *\n * @param {function} match The function that provides the matching condition.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n * @param {?string} [searchSelector] The CSS selector that an HTML element\n *   containing the given string must match. Defaults to the value of the\n *   `selector` argument.\n * @returns {MutationObserver} Augmented MutationObserver object. It has a new\n *   function mo.race added to it. This can be used by the snippets to\n *   disconnect the MutationObserver with the racing mechanism.\n *   Used like: mo.race(raceWinner(() => {mo.disconnect();}));\n * @private\n */\nexport function hideIfMatches(match, selector, searchSelector) {\n  if (searchSelector == null)\n    searchSelector = selector;\n\n  let won;\n  const callback = () => {\n    for (const element of $$(searchSelector)) {\n      const closest = $(element).closest(selector);\n      if (closest && match(element, closest)) {\n        won();\n        hideElement(closest);\n      }\n    }\n  };\n  return assign(\n    new MutationObserver(callback),\n    {\n      race(win) {\n        won = win;\n        this.observe(document, {childList: true,\n                                characterData: true,\n                                subtree: true});\n        callback();\n      }\n    }\n  );\n}\n\n/**\n * Check if an element is visible\n *\n * @param {Element} element The element to check visibility of.\n * @param {CSSStyleDeclaration} style The computed style of element.\n * @param {?Element} closest The closest parent to reach.\n * @return {bool} Whether the element is visible.\n * @private\n */\nexport function isVisible(element, style, closest) {\n  let $style = $(style, \"CSSStyleDeclaration\");\n  if ($style.getPropertyValue(\"display\") == \"none\")\n    return false;\n\n  let visibility = $style.getPropertyValue(\"visibility\");\n  if (visibility == \"hidden\" || visibility == \"collapse\")\n    return false;\n\n  if (!closest || element == closest)\n    return true;\n\n  let parent = $(element).parentElement;\n  if (!parent)\n    return true;\n\n  return isVisible(parent, getComputedStyle(parent), closest);\n}\n\n/**\n * Returns the value of the `cssText` property of the object returned by\n * `getComputedStyle` for the given element.\n *\n * If the value of the `cssText` property is blank, this function computes the\n * value out of the properties available in the object.\n *\n * @param {Element} element The element for which to get the computed CSS text.\n *\n * @returns {string} The computed CSS text.\n * @private\n */\nexport function getComputedCSSText(element) {\n  let style = getComputedStyle(element);\n  let {cssText} = style;\n\n  if (cssText)\n    return cssText;\n\n  for (let property of style)\n    cssText += `${property}: ${style[property]}; `;\n\n  return $(cssText).trim();\n}\n","import $ from \"../$.js\";\nimport {apply, call} from \"proxy-pants/function\";\n\nimport {log} from \"../introspection/log.js\";\nimport {debug} from \"../introspection/debug.js\";\nimport {hideElement, initQueryAll} from \"../utils/dom.js\";\nimport {wrapPropertyAccess} from \"../utils/execution.js\";\nimport {randomId, toRegExp} from \"../utils/general.js\";\n\n// These classes cannot be secured in a meaningful way because new nodes\n// would not use the secured prototype and the secured environment is obtained\n// though the chained counterpart of these classes. Because of this, it's OK to\n// just trap any value or prototype on the top of this file or in any other\n// file that needs global DOM classes constants or prototype. The `$(element)`\n// operation uses indeed chained version of these classes so that it's\n// transparent for the node and no prototype upgrade ever leaks in the wild.\nlet {ELEMENT_NODE, TEXT_NODE, prototype: NodeProto} = Node;\nlet {prototype: ElementProto} = Element;\nlet {prototype: HTMLElementProto} = HTMLElement;\n\nlet {\n  console,\n  variables,\n  DOMParser,\n  Error,\n  MutationObserver,\n  Object,\n  ReferenceError\n} = $(window);\n\nlet {getOwnPropertyDescriptor} = Object;\n\n/**\n * Freezes a DOM element so it prevents adding new nodes inside it.\n * @alias module:content/snippets.freeze-element\n *\n * @param {string} selector The CSS selector for the parent element that\n *   we want to freeze\n * @param {string?} [options] A single parameter for snippet's options.\n *   A string containing all the options we want to pass, each of them\n *   separated by a plus character (`+`). Empty single quotes if none (`''`).\n *   Available options:\n *   **subtree** (if we want to freeze all the element's children as well);\n *   **abort** (throw an error every time an child element gets added);\n * @param {string?} [exceptions] An array of regex/selectors used to specify\n *   the nodes we don't want to prevent being added.\n *   Each array item can be:\n *   **selector** (targeting Element nodes);\n *   **regex** (targeting Text nodes, identified by slash);\n *\n * @since Adblock Plus 3.9.5\n */\nexport function freezeElement(selector, options = \"\", ...exceptions) {\n  let observer;\n  let subtree = false;\n  let shouldAbort = false;\n  let exceptionSelectors = $(exceptions).filter(e => !isRegex(e));\n  let regexExceptions = $(exceptions).filter(e => isRegex(e)).map(toRegExp);\n  let rid = randomId();\n  let targetNodes;\n  let queryAll = initQueryAll(selector);\n\n  checkOptions();\n  let data = {\n    selector,\n    shouldAbort,\n    rid,\n    exceptionSelectors,\n    regexExceptions,\n    changeId: 0\n  };\n  if (!variables.frozen.has(document)) {\n    variables.frozen.set(document, true);\n    proxyNativeProperties();\n  }\n  observer = new MutationObserver(searchAndAttach);\n  observer.observe(document, {childList: true, subtree: true});\n  searchAndAttach();\n\n  function isRegex(s) {\n    return s.length >= 2 && s[0] == \"/\" && s[s.length - 1] == \"/\";\n  }\n\n  function checkOptions() {\n    let optionsChunks = $(options).split(\"+\");\n    if (optionsChunks.length === 1 && optionsChunks[0] === \"\")\n      optionsChunks = [];\n    for (let chunk of optionsChunks) {\n      switch (chunk) {\n        case \"subtree\":\n          subtree = true;\n          break;\n        case \"abort\":\n          shouldAbort = true;\n          break;\n        default:\n          throw new Error(\"[freeze] Unknown option passed to the snippet.\" +\n                          \" [selector]: \" + selector +\n                          \" [option]: \" + chunk);\n      }\n    }\n  }\n\n  function proxyNativeProperties() {\n    let descriptor;\n\n    descriptor = getAppendChildDescriptor(\n      NodeProto, \"appendChild\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"appendChild\", descriptor);\n\n    descriptor = getAppendChildDescriptor(\n      NodeProto, \"insertBefore\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"insertBefore\", descriptor);\n\n    descriptor = getAppendChildDescriptor(\n      NodeProto, \"replaceChild\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"replaceChild\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto, \"append\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(ElementProto, \"append\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto, \"prepend\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(ElementProto, \"prepend\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto,\n      \"replaceWith\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"replaceWith\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto,\n      \"after\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"after\", descriptor);\n\n    descriptor = getAppendDescriptor(\n      ElementProto,\n      \"before\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"before\", descriptor);\n\n    descriptor = getInsertAdjacentDescriptor(\n      ElementProto,\n      \"insertAdjacentElement\",\n      isFrozenAndInsideTarget,\n      getSnippetDataBasedOnTarget\n    );\n    wrapPropertyAccess(ElementProto, \"insertAdjacentElement\", descriptor);\n\n    descriptor = getInsertAdjacentDescriptor(\n      ElementProto,\n      \"insertAdjacentHTML\",\n      isFrozenAndInsideTarget,\n      getSnippetDataBasedOnTarget\n    );\n    wrapPropertyAccess(ElementProto, \"insertAdjacentHTML\", descriptor);\n\n    descriptor = getInsertAdjacentDescriptor(\n      ElementProto,\n      \"insertAdjacentText\",\n      isFrozenAndInsideTarget,\n      getSnippetDataBasedOnTarget\n    );\n    wrapPropertyAccess(ElementProto, \"insertAdjacentText\", descriptor);\n\n    descriptor = getInnerHTMLDescriptor(\n      ElementProto, \"innerHTML\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(ElementProto, \"innerHTML\", descriptor);\n\n    descriptor = getInnerHTMLDescriptor(\n      ElementProto,\n      \"outerHTML\",\n      isFrozenOrHasFrozenParent,\n      getSnippetDataFromNodeOrParent\n    );\n    wrapPropertyAccess(ElementProto, \"outerHTML\", descriptor);\n\n    descriptor = getTextContentDescriptor(\n      NodeProto, \"textContent\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"textContent\", descriptor);\n\n    descriptor = getTextContentDescriptor(\n      HTMLElementProto, \"innerText\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(HTMLElementProto, \"innerText\", descriptor);\n\n    descriptor = getTextContentDescriptor(\n      NodeProto, \"nodeValue\", isFrozen, getSnippetData\n    );\n    wrapPropertyAccess(NodeProto, \"nodeValue\", descriptor);\n\n    function isFrozen(node) {\n      return node && variables.frozen.has(node);\n    }\n\n    function isFrozenOrHasFrozenParent(node) {\n      try {\n        return node &&\n               (variables.frozen.has(node) ||\n               variables.frozen.has($(node).parentNode));\n      }\n      catch (error) {\n        return false;\n      }\n    }\n\n    function isFrozenAndInsideTarget(node, isInsideTarget) {\n      try {\n        return node &&\n               (variables.frozen.has(node) && isInsideTarget ||\n                variables.frozen.has($(node).parentNode) &&\n                !isInsideTarget);\n      }\n      catch (error) {\n        return false;\n      }\n    }\n\n    function getSnippetData(node) {\n      return variables.frozen.get(node);\n    }\n\n    function getSnippetDataFromNodeOrParent(node) {\n      try {\n        if (variables.frozen.has(node))\n          return variables.frozen.get(node);\n        let parent = $(node).parentNode;\n        return variables.frozen.get(parent);\n      }\n      catch (error) {}\n    }\n\n    function getSnippetDataBasedOnTarget(node, isInsideTarget) {\n      try {\n        if (variables.frozen.has(node) && isInsideTarget)\n          return variables.frozen.get(node);\n        let parent = $(node).parentNode;\n        return variables.frozen.get(parent);\n      }\n      catch (error) {}\n    }\n  }\n\n  function searchAndAttach() {\n    targetNodes = queryAll();\n    markNodes(targetNodes, false);\n  }\n\n  function markNodes(nodes, isChild = true) {\n    for (let node of nodes) {\n      if (!variables.frozen.has(node)) {\n        variables.frozen.set(node, data);\n        if (!isChild && subtree) {\n          new MutationObserver(mutationsList => {\n            for (let mutation of $(mutationsList))\n              markNodes($(mutation, \"MutationRecord\").addedNodes);\n          }).observe(node, {childList: true, subtree: true});\n        }\n        if (subtree && $(node).nodeType === ELEMENT_NODE)\n          markNodes($(node).childNodes);\n      }\n    }\n  }\n\n  // utilities\n  function logPrefixed(id, ...args) {\n    log(`[freeze][${id}] `, ...args);\n  }\n\n  function logChange(nodeOrDOMString, target, property, snippetData) {\n    let targetSelector = snippetData.selector;\n    let chgId = snippetData.changeId;\n    let isDOMString = typeof nodeOrDOMString == \"string\";\n    let action = snippetData.shouldAbort ? \"aborting\" : \"watching\";\n    console.groupCollapsed(`[freeze][${chgId}] ${action}: ${targetSelector}`);\n    switch (property) {\n      case \"appendChild\":\n      case \"append\":\n      case \"prepend\":\n      case \"insertBefore\":\n      case \"replaceChild\":\n      case \"insertAdjacentElement\":\n      case \"insertAdjacentHTML\":\n      case \"insertAdjacentText\":\n      case \"innerHTML\":\n      case \"outerHTML\":\n        logPrefixed(chgId,\n                    isDOMString ? \"text: \" : \"node: \",\n                    nodeOrDOMString);\n        logPrefixed(chgId, \"added to node: \", target);\n        break;\n      case \"replaceWith\":\n      case \"after\":\n      case \"before\":\n        logPrefixed(chgId,\n                    isDOMString ? \"text: \" : \"node: \",\n                    nodeOrDOMString);\n        logPrefixed(chgId, \"added to node: \", $(target).parentNode);\n        break;\n      case \"textContent\":\n      case \"innerText\":\n      case \"nodeValue\":\n        logPrefixed(chgId, \"content of node: \", target);\n        logPrefixed(chgId, \"changed to: \", nodeOrDOMString);\n        break;\n      default:\n        break;\n    }\n    logPrefixed(chgId, `using the function \"${property}\"`);\n    console.groupEnd();\n    snippetData.changeId++;\n  }\n\n  function isExceptionNode(element, expSelectors) {\n    if (expSelectors) {\n      let $element = $(element);\n      for (let exception of expSelectors) {\n        if ($element.matches(exception))\n          return true;\n      }\n    }\n    return false;\n  }\n\n  function isExceptionText(string, regExceptions) {\n    if (regExceptions) {\n      for (let exception of regExceptions) {\n        if (exception.test(string))\n          return true;\n      }\n    }\n    return false;\n  }\n\n  function abort(id) {\n    throw new ReferenceError(id);\n  }\n\n  // check inserted content\n  function checkHTML(htmlText, parent, property, snippetData) {\n    let domparser = new DOMParser();\n    let {body} = $(domparser.parseFromString(htmlText, \"text/html\"));\n    let nodes = $(body).childNodes;\n    let accepted = checkMultiple(nodes, parent, property, snippetData);\n    let content = $(accepted).map(node => {\n      switch ($(node).nodeType) {\n        case ELEMENT_NODE:\n          return $(node).outerHTML;\n        case TEXT_NODE:\n          return $(node).textContent;\n        default:\n          return \"\";\n      }\n    });\n    return content.join(\"\");\n  }\n\n  function checkMultiple(nodesOrDOMStrings, parent, property, snippetData) {\n    let accepted = $([]);\n    for (let nodeOrDOMString of nodesOrDOMStrings) {\n      if (checkShouldInsert(nodeOrDOMString, parent, property, snippetData))\n        accepted.push(nodeOrDOMString);\n    }\n    return accepted;\n  }\n\n  function checkShouldInsert(nodeOrDOMString, parent, property, snippetData) {\n    let aborting = snippetData.shouldAbort;\n    let regExceptions = snippetData.regexExceptions;\n    let expSelectors = snippetData.exceptionSelectors;\n    let id = snippetData.rid;\n    if (typeof nodeOrDOMString == \"string\") {\n      let domString = nodeOrDOMString;\n      if (isExceptionText(domString, regExceptions))\n        return true;\n      if (debug())\n        logChange(domString, parent, property, snippetData);\n      if (aborting)\n        abort(id);\n      return debug();\n    }\n\n    let node = nodeOrDOMString;\n    switch ($(node).nodeType) {\n      case ELEMENT_NODE:\n        if (isExceptionNode(node, expSelectors))\n          return true;\n        if (aborting) {\n          if (debug())\n            logChange(node, parent, property, snippetData);\n          abort(id);\n        }\n        if (debug()) {\n          hideElement(node);\n          logChange(node, parent, property, snippetData);\n          return true;\n        }\n        return false;\n      case TEXT_NODE:\n        if (isExceptionText($(node).textContent, regExceptions))\n          return true;\n        if (debug())\n          logChange(node, parent, property, snippetData);\n        if (aborting)\n          abort(id);\n        return false;\n      default:\n        return true;\n    }\n  }\n\n  // descriptors\n  function getAppendChildDescriptor(target, property, shouldValidate,\n                                    getSnippetData) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let origin = desc.get && call(desc.get, target) || desc.value;\n    if (!origin)\n      return;\n\n    return {\n      get() {\n        return function(...args) {\n          if (shouldValidate(this)) {\n            let snippetData = getSnippetData(this);\n            if (snippetData) {\n              let incomingNode = args[0];\n              if (!checkShouldInsert(incomingNode, this, property, snippetData))\n                return incomingNode;\n            }\n          }\n          return apply(origin, this, args);\n        };\n      }\n    };\n  }\n\n  function getAppendDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let origin = desc.get && call(desc.get, target) || desc.value;\n    if (!origin)\n      return;\n    return {\n      get() {\n        return function(...nodesOrDOMStrings) {\n          if (!shouldValidate(this))\n            return apply(origin, this, nodesOrDOMStrings);\n\n          let snippetData = getSnippetData(this);\n          if (!snippetData)\n            return apply(origin, this, nodesOrDOMStrings);\n\n          let accepted = checkMultiple(\n            nodesOrDOMStrings, this, property, snippetData\n          );\n          if (accepted.length > 0)\n            return apply(origin, this, accepted);\n        };\n      }\n    };\n  }\n\n  function getInsertAdjacentDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let origin = desc.get && call(desc.get, target) || desc.value;\n    if (!origin)\n      return;\n\n    return {\n      get() {\n        return function(...args) {\n          let [position, value] = args;\n          let isInsideTarget =\n              position === \"afterbegin\" || position === \"beforeend\";\n          if (shouldValidate(this, isInsideTarget)) {\n            let snippetData = getSnippetData(this, isInsideTarget);\n            if (snippetData) {\n              let parent = isInsideTarget ?\n                           this :\n                           $(this).parentNode;\n              let finalValue;\n              switch (property) {\n                case \"insertAdjacentElement\":\n                  if (!checkShouldInsert(value, parent, property, snippetData))\n                    return value;\n                  break;\n\n                case \"insertAdjacentHTML\":\n                  finalValue = checkHTML(value, parent, property, snippetData);\n                  if (finalValue)\n                    return call(origin, this, position, finalValue);\n\n\n                  return;\n\n                case \"insertAdjacentText\":\n                  if (!checkShouldInsert(value, parent, property, snippetData))\n                    return;\n                  break;\n\n                default:\n                  break;\n              }\n            }\n          }\n          return apply(origin, this, args);\n        };\n      }\n    };\n  }\n\n  function getInnerHTMLDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let {set: prevSetter} = desc;\n    if (!prevSetter)\n      return;\n\n    return {\n      set(htmlText) {\n        if (!shouldValidate(this))\n          return call(prevSetter, this, htmlText);\n\n        let snippetData = getSnippetData(this);\n        if (!snippetData)\n          return call(prevSetter, this, htmlText);\n        let finalValue = checkHTML(htmlText, this, property, snippetData);\n        if (finalValue)\n          return call(prevSetter, this, finalValue);\n      }\n    };\n  }\n\n  function getTextContentDescriptor(\n    target, property, shouldValidate, getSnippetData\n  ) {\n    let desc = getOwnPropertyDescriptor(target, property) || {};\n    let {set: prevSetter} = desc;\n    if (!prevSetter)\n      return;\n\n    return {\n      set(domString) {\n        if (!shouldValidate(this))\n          return call(prevSetter, this, domString);\n\n        let snippetData = getSnippetData(this);\n        if (!snippetData)\n          return call(prevSetter, this, domString);\n        if (checkShouldInsert(domString, this, property, snippetData))\n          return call(prevSetter, this, domString);\n      }\n    };\n  }\n}\n","import $ from \"../$.js\";\nimport {noop} from \"./log.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Array, Error, Map, parseInt} = $(window);\n\nlet stack = null;\nlet won = null;\n\n// #$#race start; thing1; thing2; race stop;\n\n/**\n * Delimits a race among filters, to be able to disable competing filters when\n * any of them \"wins the race\". `#$#race start; filter1; filter2; race end;`\n * @param {string} action either `start` or `stop` the race.\n * @param {string} winners the amount of possible race's winners: 1 by default.\n */\nexport function race(action, winners = \"1\") {\n  switch (action) {\n    case \"start\":\n      stack = {\n        winners: parseInt(winners, 10) || 1,\n        participants: new Map()\n      };\n      won = new Array();\n      break;\n    case \"end\":\n    case \"finish\":\n    case \"stop\":\n      stack = null;\n      for (let win of won)\n        win();\n      won = null;\n      break;\n    default:\n      throw new Error(`Invalid action: ${action}`);\n  }\n}\n\n/**\n * Returns a function that, when a race is happening, can mark a winner,\n * by invoking all callbacks passed for every other snippet that lost the race.\n * @param {string} name the snippet name that is racing.\n * @param {function} lose a callback that, once invoked, will stop the snippet.\n * @returns {function} a callback to invoke whenever a match happens.\n */\nexport function raceWinner(name, lose) {\n  // without races, every invoke is a noop\n  if (stack === null)\n    return noop;\n\n  // within races though, trap the current stack and winners because more than\n  // a race could be defined for the same domains / filters\n  let current = stack;\n  let {participants} = current;\n  participants.set(win, lose);\n\n  // return a function that, once invoked, becomes a noop every other time and\n  // also invokes every other functions in the race to stop them as loosers\n  return win;\n\n  function win() {\n    // make the noop case the fastest one for any further invoke\n    if (current.winners < 1)\n      return;\n\n    let debugLog = getDebugger(\"race\");\n    debugLog(`${name} won the race`);\n\n    // in case a snippet wins while the race is still happening, queue them all\n    // so that unknown racing snippets get a chance to be disabled later on.\n    // i.e. race start 2; winner1; looser2; winner3; looser4; race end;\n    if (current === stack) {\n      won.push(win);\n    }\n    else {\n      participants.delete(win);\n      if (--current.winners < 1) {\n        for (let looser of participants.values())\n          looser();\n\n        participants.clear();\n      }\n    }\n  }\n}\n","import $ from \"../$.js\";\nimport {apply, proxy} from \"proxy-pants/function\";\n\nimport {toRegExp} from \"../utils/general.js\";\nimport {hideElement} from \"../utils/dom.js\";\nimport {raceWinner} from \"../introspection/race.js\";\n\nconst {Map, MutationObserver, Object, Set, WeakSet} = $(window);\n\nlet ElementProto = Element.prototype;\nlet {attachShadow} = ElementProto;\n\nlet hiddenShadowRoots = new WeakSet();\nlet searches = new Map();\nlet observer = null;\n\n/**\n * Hides any HTML element or one of its ancestors matching a CSS selector if\n * the text content of the element's shadow contains a given string.\n * @alias module:content/snippets.hide-if-shadow-contains\n *\n * @param {string} search The string to look for in every HTML element's\n *   shadow. If the string begins and ends with a slash (`/`), the text in\n *   between is treated as a regular expression.\n * @param {string} selector The CSS selector that an HTML element must match\n *   for it to be hidden.\n *\n * @since Adblock Plus 3.3\n */\nexport function hideIfShadowContains(search, selector = \"*\") {\n  // Add new searches only if needed, accordingly with the selector.\n  let key = `${search}\\\\${selector}`;\n  if (!searches.has(key)) {\n    searches.set(key, [toRegExp(search), selector, raceWinner(\n      \"hide-if-shadow-contains\",\n      () => {\n        searches.delete(key);\n      })\n    ]);\n  }\n\n  // Bootstrap the observer and the proxied attachShadow wrap once.\n  if (!observer) {\n    observer = new MutationObserver(records => {\n      let visited = new Set();\n      for (let {target} of $(records)) {\n        // retrieve the ShadowRoot\n        let parent = $(target).parentNode;\n        while (parent)\n          [target, parent] = [parent, $(target).parentNode];\n\n        // avoid checking hidden shadow roots\n        if (hiddenShadowRoots.has(target))\n          continue;\n\n        // avoid checking twice the same shadow root node\n        if (visited.has(target))\n          continue;\n\n        visited.add(target);\n\n        for (let [re, selfOrParent, win] of searches.values()) {\n          if (re.test($(target).textContent)) {\n            let closest = $(target.host).closest(selfOrParent);\n            if (closest) {\n              win();\n              // always hide the host of shadow-root\n              $(target).appendChild(\n                document.createElement(\"style\")\n              ).textContent = \":host {display: none !important}\";\n              // hide desired element, which is the host itself\n              // or one of its ancestors\n              hideElement(closest);\n              // mark shadow root as hidden\n              hiddenShadowRoots.add(target);\n            }\n          }\n        }\n      }\n    });\n\n    Object.defineProperty(ElementProto, \"attachShadow\", {\n      // Proxy whatever was set as attachShadow\n      value: proxy(attachShadow, function() {\n        // Create the shadow root first. It doesn't matter if it's a closed\n        // shadow root, we keep the reference in a weak map.\n        let root = apply(attachShadow, this, arguments);\n\n        // Listen for relevant DOM mutations in the shadow.\n        observer.observe(root, {\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n\n        return root;\n      })\n    });\n  }\n}\n","import $ from \"../$.js\";\nimport {apply, proxy} from \"proxy-pants/function\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {findOwner, overrideValue} from \"../utils/execution.js\";\n\nconst {Error, JSON, Map, Object} = $(window);\n\n// will be a Map of all paths, once the snippet is used at least once\nlet paths = null;\n\n/**\n * Traps calls to JSON.parse, and if the result of the parsing is an Object, it\n * will replace specified properties from the result before returning to the\n * caller.\n * @alias module:content/snippets.json-override\n *\n * @param {string} rawOverridePaths A list of space-separated properties\n * to replace.\n * @param {string} value The value to override the properties with.\n * Possible values to override the property with:\n *   undefined\n *   false\n *   true\n *   null\n *   noopFunc    - function with empty body\n *   trueFunc    - function returning true\n *   falseFunc   - function returning false\n *   ''          - empty string\n *   positive decimal integer, no sign, with maximum value of 0x7FFF\n *   emptyArray  - an array with no elements\n *   emptyObject - an object with no properties\n *\n * @param {?string} [rawNeedlePaths] A list of space-separated properties which\n *   must be all present for the pruning to occur.\n * @param {?string} [filter] A string to look for in the raw string,\n * before it's passed to JSON.parse.\n * If no match is found no further search is done on the resulting object.\n * If the string begins and ends with a slash (/),\n * the text in between is treated as a regular expression.\n *\n * @since Adblock Plus 3.11.2\n */\nexport function jsonOverride(rawOverridePaths, value,\n                             rawNeedlePaths = \"\", filter = \"\") {\n  if (!rawOverridePaths)\n    throw new Error(\"[json-override snippet]: Missing paths to override.\");\n\n  if (typeof value == \"undefined\")\n    throw new Error(\"[json-override snippet]: No value to override with.\");\n\n  if (!paths) {\n    let debugLog = getDebugger(\"json-override\");\n\n    // allow both jsonPrune and jsonOverride to work together\n    let {parse} = JSON;\n    paths = new Map();\n\n    Object.defineProperty(window.JSON, \"parse\", {\n      value: proxy(parse, function(str) {\n        let result = apply(parse, this, arguments);\n\n        for (let {prune, needle, filter: flt, value: val} of paths.values()) {\n          if (flt && !flt.test(str))\n            continue;\n\n          if ($(needle).some(path => !findOwner(result, path)))\n            return result;\n\n          for (let path of prune) {\n            let details = findOwner(result, path);\n            if (typeof details != \"undefined\") {\n              debugLog(`Found ${path} replaced it with ${val}`);\n              details[0][details[1]] = overrideValue(val);\n            }\n          }\n        }\n\n        return result;\n      })\n    });\n    debugLog(\"Wrapped JSON.parse for override\");\n  }\n\n  // allow a single unique rawOverridePaths definition per domain\n  // TBD: should we throw an error if it was already set?\n  paths.set(rawOverridePaths, {\n    prune: $(rawOverridePaths).split(/ +/),\n    needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : [],\n    filter: filter ? toRegExp(filter) : null,\n    value\n  });\n}\n","import $ from \"../$.js\";\nimport {apply, proxy} from \"proxy-pants/function\";\n\nimport {findOwner} from \"../utils/execution.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Error, JSON, Map, Object} = $(window);\n\n// will be a Map of all paths, once the snippet is used at least once\nlet paths = null;\n\n/**\n * Traps calls to JSON.parse, and if the result of the parsing is an Object, it\n * will remove specified properties from the result before returning to the\n * caller.\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/gorhill/uBlock/commit/2fd86a66).\n * @alias module:content/snippets.json-prune\n *\n * @param {string} rawPrunePaths A list of space-separated properties to remove.\n * @param {?string} [rawNeedlePaths] A list of space-separated properties which\n *   must be all present for the pruning to occur.\n *\n * @since Adblock Plus 3.9.0\n */\nexport function jsonPrune(rawPrunePaths, rawNeedlePaths = \"\") {\n  if (!rawPrunePaths)\n    throw new Error(\"Missing paths to prune\");\n\n  if (!paths) {\n    let debugLog = getDebugger(\"json-prune\");\n    // allow both jsonPrune and jsonOverride to work together\n    let {parse} = JSON;\n    paths = new Map();\n\n    Object.defineProperty(window.JSON, \"parse\", {\n      value: proxy(parse, function() {\n        let result = apply(parse, this, arguments);\n\n        for (let {prune, needle} of paths.values()) {\n          if ($(needle).some(path => !findOwner(result, path)))\n            return result;\n\n          for (let path of prune) {\n            let details = findOwner(result, path);\n            if (typeof details != \"undefined\") {\n              debugLog(`Found ${path} and deleted`);\n              delete details[0][details[1]];\n            }\n          }\n        }\n\n        return result;\n      })\n    });\n    debugLog(\"Wrapped JSON.parse for prune\");\n  }\n\n  // allow a single unique rawPrunePaths definition per domain\n  // TBD: should we throw an error if it was already set?\n  paths.set(rawPrunePaths, {\n    prune: $(rawPrunePaths).split(/ +/),\n    needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : []\n  });\n}\n","import $ from \"../$.js\";\n\nimport {getDebugger} from \"../introspection/log.js\";\nimport {overrideValue, wrapPropertyAccess} from \"../utils/execution.js\";\n\nlet {Error} = $(window);\n\n/**\n * Overrides a property's value on the window object with a set of\n * available properties.\n *\n * Possible values to override the property with:\n *   undefined\n *   false\n *   true\n *   null\n *   noopFunc   - function with empty body\n *   trueFunc   - function returning true\n *   falseFunc  - function returning false\n *   emptyArray  - an array with no elements\n *   emptyObject - an object with no properties\n *   ''         - empty string\n *   positive decimal integer, no sign, with maximum value of 0x7FFF\n *\n * The idea originates from\n * [uBlock Origin](https://github.com/uBlockOrigin/uAssets/blob/80b195436f8f8d78ba713237bfc268ecfc9d9d2b/filters/resources.txt#L2105).\n * @alias module:content/snippets.override-property-read\n *\n * @param {string} property The name of the property.\n * @param {string} value The value to override the property with.\n *\n * @since Adblock Plus 3.9.4\n */\nexport function overridePropertyRead(property, value) {\n  if (!property) {\n    throw new Error(\"[override-property-read snippet]: \" +\n                     \"No property to override.\");\n  }\n  if (typeof value === \"undefined\") {\n    throw new Error(\"[override-property-read snippet]: \" +\n                     \"No value to override with.\");\n  }\n\n  let debugLog = getDebugger(\"override-property-read\");\n\n  let cValue = overrideValue(value);\n\n  let newGetter = () => {\n    debugLog(`${property} override done.`);\n    return cValue;\n  };\n\n  debugLog(`Overriding ${property}.`);\n\n  wrapPropertyAccess(window, property, {get: newGetter, set() {}});\n}\n","import $ from \"../$.js\";\nimport {apply, call, proxy} from \"proxy-pants/function\";\n\nimport {debug} from \"../introspection/debug.js\";\nimport {toRegExp} from \"../utils/general.js\";\nimport {getDebugger} from \"../introspection/log.js\";\n\nlet {Error, Map, Object, console} = $(window);\n\nlet {toString} = Function.prototype;\nlet EventTargetProto = EventTarget.prototype;\nlet {addEventListener} = EventTargetProto;\n\n// will be a Map of all events, once the snippet is used at least once\nlet events = null;\n\n/**\n * Prevents adding event listeners.\n * @alias module:content/snippets.prevent-listener\n *\n * @param {string} event Pattern that matches the type(s) of event\n * we want to prevent. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {?string} eventHandler Pattern that matches the event handler's\n * declaration. If the string starts and ends with a slash (`/`),\n * the text in between is treated as a regular expression.\n * @param {?string} selector The CSS selector that the event target must match.\n * If the event target is not an HTML element the event handler is added.\n * @since Adblock Plus 3.11.2\n */\nexport function preventListener(event, eventHandler, selector) {\n  if (!event)\n    throw new Error(\"[prevent-listener snippet]: No event type.\");\n\n  if (!events) {\n    events = new Map();\n\n    let debugLog = getDebugger(\"[prevent]\");\n\n    Object.defineProperty(EventTargetProto, \"addEventListener\", {\n      value: proxy(addEventListener, function(type, listener) {\n        for (let {evt, handlers, selectors} of events.values()) {\n          // bail out ASAP if current type doesn't match\n          if (!evt.test(type))\n            continue;\n\n          let isElement = this instanceof Element;\n\n          // check every possible handler and selector per same event type\n          for (let i = 0; i < handlers.length; i++) {\n            let handler = handlers[i];\n            let sel = selectors[i];\n\n            let handlerMatch = () => handler.test(\n              call(\n                toString,\n                typeof listener === \"function\" ?\n                  listener : listener.handleEvent\n              )\n            );\n\n            if (\n              (handler && !handlerMatch()) ||\n              (sel && !(isElement && $(this).matches(sel)))\n            )\n              continue;\n\n            if (debug()) {\n              console.groupCollapsed(\"DEBUG [prevent] was successful\");\n              debugLog(`type: ${type} matching ${evt}`);\n              debugLog(\"handler:\", listener);\n              if (handler)\n                debugLog(`matching ${handler}`);\n              if (sel)\n                debugLog(\"on element: \", this, ` matching ${sel}`);\n              debugLog(\"was prevented from being added\");\n              console.groupEnd();\n            }\n            return;\n          }\n        }\n        return apply(addEventListener, this, arguments);\n      })\n    });\n\n    debugLog(\"Wrapped addEventListener\");\n  }\n\n  if (!events.has(event))\n    events.set(event, {evt: toRegExp(event), handlers: [], selectors: []});\n\n  let {handlers, selectors} = events.get(event);\n\n  handlers.push(eventHandler ? toRegExp(eventHandler) : null);\n  selectors.push(selector);\n}\n","import $ from \"../$.js\";\nimport {apply, caller, proxy} from \"proxy-pants/function\";\n\nimport {toRegExp} from \"../utils/general.js\";\n\nlet {URL, fetch} = $(window);\n\n// purposely a trap for the native URLSearchParams.prototype\nlet {delete: deleteParam} = caller(URLSearchParams.prototype);\n\nlet parameters;\n\n/**\n * Strips a query string parameter from `fetch()` calls.\n * @alias module:content/snippets.strip-fetch-query-parameter\n *\n * @param {string} name The name of the parameter.\n * @param {?string} [urlPattern] An optional pattern that the URL must match.\n *\n * @since Adblock Plus 3.5.1\n */\nexport function stripFetchQueryParameter(name, urlPattern = null) {\n  // override the `window.fetch` only once\n  if (!parameters) {\n    parameters = new Map();\n    window.fetch = proxy(fetch, (...args) => {\n      let [source] = args;\n      if (typeof source === \"string\") {\n        let url = new URL(source);\n        for (let [key, reg] of parameters) {\n          if (!reg || reg.test(source)) {\n            deleteParam(url.searchParams, key);\n            args[0] = url.href;\n          }\n        }\n      }\n      return apply(fetch, self, args);\n    });\n  }\n\n  parameters.set(name, urlPattern && toRegExp(urlPattern));\n}\n","import {log} from \"../introspection/log.js\";\nimport {apply} from \"proxy-pants/function\";\n\n/**\n * Similar to `log`, but does the logging in the context of the document rather\n * than the content script.\n *\n * This may be used for testing and debugging, especially to verify that the\n * injection of snippets into the document is working without any errors.\n * @alias module:content/snippets.trace\n *\n * @param {...*} [args] The arguments to log.\n *\n * @since Adblock Plus 3.3\n */\nexport function trace(...args) {\n  // We could simply use console.log here, but the goal is to demonstrate the\n  // usage of snippet dependencies.\n  apply(log, null, args);\n}\n","export const injectedSnippetsList = [\n  \"abort-current-inline-script\",\n  \"abort-on-iframe-property-read\",\n  \"abort-on-iframe-property-write\",\n  \"abort-on-property-read\",\n  \"abort-on-property-write\",\n  \"cookie-remover\",\n  \"debug\",\n  \"freeze-element\",\n  \"hide-if-shadow-contains\",\n  \"json-override\",\n  \"json-prune\",\n  \"override-property-read\",\n  \"prevent-listener\",\n  \"strip-fetch-query-parameter\",\n  \"trace\"\n];\n","import {abortCurrentInlineScript} from\n  \"../content/behavioral/abort-current-inline-script.js\";\nimport {abortOnIframePropertyRead} from\n  \"../content/behavioral/abort-on-iframe-property-read.js\";\nimport {abortOnIframePropertyWrite} from\n  \"../content/behavioral/abort-on-iframe-property-write.js\";\nimport {abortOnPropertyRead} from\n  \"../content/behavioral/abort-on-property-read.js\";\nimport {abortOnPropertyWrite} from\n  \"../content/behavioral/abort-on-property-write.js\";\nimport {cookieRemover} from \"../content/behavioral/cookie-remover.js\";\nimport {setDebug as debug} from \"../content/introspection/debug.js\";\nimport {freezeElement} from \"../content/behavioral/freeze-element.js\";\nimport {hideIfShadowContains} from\n  \"../content/conditional-hiding/hide-if-shadow-contains.js\";\nimport {jsonOverride} from \"../content/behavioral/json-override.js\";\nimport {jsonPrune} from \"../content/behavioral/json-prune.js\";\nimport {overridePropertyRead} from\n  \"../content/behavioral/override-property-read.js\";\nimport {preventListener} from \"../content/behavioral/prevent-listener.js\";\nimport {stripFetchQueryParameter} from\n  \"../content/behavioral/strip-fetch-query-parameter.js\";\nimport {trace} from \"../content/introspection/trace.js\";\n\nimport {injectedSnippetsList} from \"./injectedMeta.js\";\n\n// WARNING: this list is ordered alphabetically and the elements must\n// match the order of the injectedSnippetsList.\nconst injectedSnippetsCallbacks = [\n  abortCurrentInlineScript,\n  abortOnIframePropertyRead,\n  abortOnIframePropertyWrite,\n  abortOnPropertyRead,\n  abortOnPropertyWrite,\n  cookieRemover,\n  debug,\n  freezeElement,\n  hideIfShadowContains,\n  jsonOverride,\n  jsonPrune,\n  overridePropertyRead,\n  preventListener,\n  stripFetchQueryParameter,\n  trace\n];\n\nconst snippets = {};\n\nfor (let i = 0, {length} = injectedSnippetsList; i < length; i++)\n  snippets[injectedSnippetsList[i]] = injectedSnippetsCallbacks[i];\n\n// WARNING: this is needed to build artifacts via rollup\nsnippets.trace();\n"],"names":["$","Proxy","apply","a","bind","b","call","c","Function","callerHandler","get","target","name","caller","proxy","source","_","self","args","handler","bound","assign","defineProperties","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getPrototypeOf","Object","hasOwnProperty","species","Symbol","Native","Secure","proto","prototype","constructor","statics","length","value","secure","libEnvironment","environment","globalThis","window","ownKeys","Reflect","worldEnvDefined","isIsolatedWorld","world","isMainWorld","isChrome","chrome","runtime","isOtherThanChrome","browser","isExtensionContext","copyIfExtension","create","defineProperty","invokes","classes","Map","RegExp","Set","WeakMap","WeakSet","augment","method","known","key","includes","descriptor","primitive","Super","Class","toString","valueOf","type","toLowerCase","callback","result","this","arguments","variables","frozen","hidden","iframePropertiesToAbort","read","write","abortedIframes","startsCapitalized","console","document","performance","JSON","Math","Number","String","MouseEvent","map","has","test","set","WeakValue","helpers","ws","wm","wv","any","add","setTimeout","env","cleanup","cleanUpCallback","clear","transformOnce","super","concat","join","reduce","unshift","descriptors","chain","current","chained","Array","isArray","setPrototypeOf","slice","getBrand","nodeType","Node","Attr","CanvasRenderingContext2D","CSSStyleDeclaration","Document","Element","HTMLCanvasElement","HTMLElement","HTMLImageElement","HTMLScriptElement","MutationRecord","ShadowRoot","CSS2Properties","upgrade","hint","brand","Error","transformer","context","accessor","debugging","debug","setDebug","noop","log","getDebugger","regexEscape","string","replace","toRegExp","pattern","isCaseSensitive","endsWith","push","randomId","floor","random","parseFloat","ReferenceError","onerror","NodeProto","ElementProto","propertyAccessors","wrapPropertyAccess","object","property","$property","dotIndex","indexOf","currentDescriptor","configurable","newDescriptor","propertyValue","properties","toBeWrapped","newValue","prop","desc","overrideOnError","magic","prev","message","abortOnRead","loggingPrefix","debugLog","rid","abort","abortOnWrite","abortOnIframe","abortRead","abortWrite","frame","from","frames","queryAndProxyIframe","addHooksOnDomAdditions","readProps","size","props","writeProps","endCallback","wrapAccess","getInnerHTMLDescriptor","names","getAppendChildDescriptor","currentValue","prevSetter","val","NativeObject","findOwner","root","path","split","i","decimals","overrideValue","Script","abortCurrentInlineScript","api","search","re","us","currentScript","pop","node","prevGetter","element","src","textContent","abortOnIframePropertyRead","abortOnIframePropertyWrite","abortOnPropertyRead","abortOnPropertyWrite","cookie","documentCookies","cookieRemover","location","protocol","pair","getCookieMatches","$hostname","hostname","expires","domain","trim","arr","filter","str","getComputedStyle","MutationObserver","XPathEvaluator","XPathExpression","XPathResult","querySelectorAll","$$","$XPathExpression","evaluate","$XPathEvaluator","createExpression","hideElement","notifyElementHidden","style","$style","debugCSSProperties","setProperty","getPropertyValue","propertyPriority","getPropertyPriority","observe","attributes","attributeFilter","checkElement","initQueryAndApply","selector","$selector","startsWith","xpathQuery","evaluator","expression","flag","ORDERED_NODE_SNAPSHOT_TYPE","cb","snapshotLength","snapshotItem","forEach","initQueryAll","queryAndApply","elements","e","ELEMENT_NODE","TEXT_NODE","HTMLElementProto","DOMParser","freezeElement","options","exceptions","observer","subtree","shouldAbort","exceptionSelectors","isRegex","regexExceptions","targetNodes","queryAll","checkOptions","data","changeId","proxyNativeProperties","searchAndAttach","childList","s","optionsChunks","chunk","isFrozen","getSnippetData","getAppendDescriptor","isFrozenOrHasFrozenParent","getSnippetDataFromNodeOrParent","getInsertAdjacentDescriptor","isFrozenAndInsideTarget","getSnippetDataBasedOnTarget","getTextContentDescriptor","parentNode","error","isInsideTarget","parent","markNodes","nodes","isChild","mutationsList","mutation","addedNodes","childNodes","logPrefixed","id","logChange","nodeOrDOMString","snippetData","targetSelector","chgId","isDOMString","action","groupCollapsed","groupEnd","isExceptionNode","expSelectors","$element","exception","matches","isExceptionText","regExceptions","checkHTML","htmlText","domparser","body","parseFromString","accepted","checkMultiple","content","outerHTML","nodesOrDOMStrings","checkShouldInsert","aborting","domString","shouldValidate","origin","incomingNode","position","finalValue","raceWinner","lose","attachShadow","hiddenShadowRoots","searches","hideIfShadowContains","records","visited","selfOrParent","win","values","closest","host","appendChild","createElement","characterData","paths","jsonOverride","rawOverridePaths","rawNeedlePaths","parse","prune","needle","flt","some","details","jsonPrune","rawPrunePaths","overridePropertyRead","cValue","newGetter","EventTargetProto","EventTarget","addEventListener","events","preventListener","event","eventHandler","listener","evt","handlers","selectors","isElement","sel","handlerMatch","handleEvent","URL","fetch","delete","deleteParam","URLSearchParams","parameters","stripFetchQueryParameter","urlPattern","url","reg","searchParams","href","trace","injectedSnippetsList","injectedSnippetsCallbacks","snippets"],"mappings":"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"}